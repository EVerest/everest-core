// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: control_service/types.proto
// Protobuf C++ Version: 5.27.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_control_5fservice_2ftypes_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_control_5fservice_2ftypes_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_control_5fservice_2ftypes_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_control_5fservice_2ftypes_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_control_5fservice_2ftypes_2eproto;
namespace control_service {
class DeviceCategory;
struct DeviceCategoryDefaultTypeInternal;
extern DeviceCategoryDefaultTypeInternal _DeviceCategory_default_instance_;
class DeviceType;
struct DeviceTypeDefaultTypeInternal;
extern DeviceTypeDefaultTypeInternal _DeviceType_default_instance_;
class EntityType;
struct EntityTypeDefaultTypeInternal;
extern EntityTypeDefaultTypeInternal _EntityType_default_instance_;
class UseCase;
struct UseCaseDefaultTypeInternal;
extern UseCaseDefaultTypeInternal _UseCase_default_instance_;
class UseCaseEvent;
struct UseCaseEventDefaultTypeInternal;
extern UseCaseEventDefaultTypeInternal _UseCaseEvent_default_instance_;
class UseCase_ActorType;
struct UseCase_ActorTypeDefaultTypeInternal;
extern UseCase_ActorTypeDefaultTypeInternal _UseCase_ActorType_default_instance_;
class UseCase_NameType;
struct UseCase_NameTypeDefaultTypeInternal;
extern UseCase_NameTypeDefaultTypeInternal _UseCase_NameType_default_instance_;
}  // namespace control_service
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace control_service {
enum DeviceCategory_Enum : int {
  DeviceCategory_Enum_UNKNOWN = 0,
  DeviceCategory_Enum_GRID_CONNECTION_HUB = 1,
  DeviceCategory_Enum_ENERGY_MANAGEMENT_SYSTEM = 2,
  DeviceCategory_Enum_E_MOBILITY = 3,
  DeviceCategory_Enum_HVAC = 4,
  DeviceCategory_Enum_INVERTER = 5,
  DeviceCategory_Enum_DOMESTIC_APPLIANCE = 6,
  DeviceCategory_Enum_METERING = 7,
  DeviceCategory_Enum_DeviceCategory_Enum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DeviceCategory_Enum_DeviceCategory_Enum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DeviceCategory_Enum_IsValid(int value);
extern const uint32_t DeviceCategory_Enum_internal_data_[];
constexpr DeviceCategory_Enum DeviceCategory_Enum_Enum_MIN = static_cast<DeviceCategory_Enum>(0);
constexpr DeviceCategory_Enum DeviceCategory_Enum_Enum_MAX = static_cast<DeviceCategory_Enum>(7);
constexpr int DeviceCategory_Enum_Enum_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
DeviceCategory_Enum_descriptor();
template <typename T>
const std::string& DeviceCategory_Enum_Name(T value) {
  static_assert(std::is_same<T, DeviceCategory_Enum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Enum_Name().");
  return DeviceCategory_Enum_Name(static_cast<DeviceCategory_Enum>(value));
}
template <>
inline const std::string& DeviceCategory_Enum_Name(DeviceCategory_Enum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DeviceCategory_Enum_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool DeviceCategory_Enum_Parse(absl::string_view name, DeviceCategory_Enum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceCategory_Enum>(
      DeviceCategory_Enum_descriptor(), name, value);
}
enum EntityType_Enum : int {
  EntityType_Enum_UNKNOWN = 0,
  EntityType_Enum_Battery = 1,
  EntityType_Enum_Compressor = 2,
  EntityType_Enum_DeviceInformation = 3,
  EntityType_Enum_DHWCircuit = 4,
  EntityType_Enum_DHWStorage = 5,
  EntityType_Enum_Dishwasher = 6,
  EntityType_Enum_Dryer = 7,
  EntityType_Enum_ElectricalImmersionHeater = 8,
  EntityType_Enum_Fan = 9,
  EntityType_Enum_GasHeatingAppliance = 10,
  EntityType_Enum_Generic = 11,
  EntityType_Enum_HeatingBufferStorage = 12,
  EntityType_Enum_HeatingCircuit = 13,
  EntityType_Enum_HeatingObject = 14,
  EntityType_Enum_HeatingZone = 15,
  EntityType_Enum_HeatPumpAppliance = 16,
  EntityType_Enum_HeatSinkCircuit = 17,
  EntityType_Enum_HeatSourceCircuit = 18,
  EntityType_Enum_HeatSourceUnit = 19,
  EntityType_Enum_HvacController = 20,
  EntityType_Enum_HvacRoom = 21,
  EntityType_Enum_InstantDHWHeater = 22,
  EntityType_Enum_Inverter = 23,
  EntityType_Enum_OilHeatingAppliance = 24,
  EntityType_Enum_Pump = 25,
  EntityType_Enum_RefrigerantCircuit = 26,
  EntityType_Enum_SmartEnergyAppliance = 27,
  EntityType_Enum_SolarDHWStorage = 28,
  EntityType_Enum_SolarThermalCircuit = 29,
  EntityType_Enum_SubMeterElectricity = 30,
  EntityType_Enum_TemperatureSensor = 31,
  EntityType_Enum_Washer = 32,
  EntityType_Enum_BatterySystem = 33,
  EntityType_Enum_ElectricityGenerationSystem = 34,
  EntityType_Enum_ElectricityStorageSystem = 35,
  EntityType_Enum_GridConnectionPointOfPremises = 36,
  EntityType_Enum_Household = 37,
  EntityType_Enum_PVSystem = 38,
  EntityType_Enum_EV = 39,
  EntityType_Enum_EVSE = 40,
  EntityType_Enum_ChargingOutlet = 41,
  EntityType_Enum_CEM = 42,
  EntityType_Enum_PV = 43,
  EntityType_Enum_PVESHybrid = 44,
  EntityType_Enum_ElectricalStorage = 45,
  EntityType_Enum_PVString = 46,
  EntityType_Enum_GridGuard = 47,
  EntityType_Enum_ControllableSystem = 48,
  EntityType_Enum_EntityType_Enum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EntityType_Enum_EntityType_Enum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EntityType_Enum_IsValid(int value);
extern const uint32_t EntityType_Enum_internal_data_[];
constexpr EntityType_Enum EntityType_Enum_Enum_MIN = static_cast<EntityType_Enum>(0);
constexpr EntityType_Enum EntityType_Enum_Enum_MAX = static_cast<EntityType_Enum>(48);
constexpr int EntityType_Enum_Enum_ARRAYSIZE = 48 + 1;
const ::google::protobuf::EnumDescriptor*
EntityType_Enum_descriptor();
template <typename T>
const std::string& EntityType_Enum_Name(T value) {
  static_assert(std::is_same<T, EntityType_Enum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Enum_Name().");
  return EntityType_Enum_Name(static_cast<EntityType_Enum>(value));
}
template <>
inline const std::string& EntityType_Enum_Name(EntityType_Enum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EntityType_Enum_descriptor,
                                                 0, 48>(
      static_cast<int>(value));
}
inline bool EntityType_Enum_Parse(absl::string_view name, EntityType_Enum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityType_Enum>(
      EntityType_Enum_descriptor(), name, value);
}
enum DeviceType_Enum : int {
  DeviceType_Enum_UNKNOWN = 0,
  DeviceType_Enum_DISHWASHER = 1,
  DeviceType_Enum_DRYER = 2,
  DeviceType_Enum_ENVIRONMENT_SENSOR = 3,
  DeviceType_Enum_GENERIC = 4,
  DeviceType_Enum_HEAT_GENERATION_SYSTEM = 5,
  DeviceType_Enum_HEAT_SINK_SYSTEM = 6,
  DeviceType_Enum_HEAT_STORAGE_SYSTEM = 7,
  DeviceType_Enum_HVAC_CONTROLLER = 8,
  DeviceType_Enum_SUBMETER = 9,
  DeviceType_Enum_WASHER = 10,
  DeviceType_Enum_ELECTRICITY_SUPPLY_SYSTEM = 11,
  DeviceType_Enum_ENERGY_MANAGEMENT_SYSTEM = 12,
  DeviceType_Enum_INVERTER = 13,
  DeviceType_Enum_CHARGING_STATION = 14,
  DeviceType_Enum_DeviceType_Enum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DeviceType_Enum_DeviceType_Enum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DeviceType_Enum_IsValid(int value);
extern const uint32_t DeviceType_Enum_internal_data_[];
constexpr DeviceType_Enum DeviceType_Enum_Enum_MIN = static_cast<DeviceType_Enum>(0);
constexpr DeviceType_Enum DeviceType_Enum_Enum_MAX = static_cast<DeviceType_Enum>(14);
constexpr int DeviceType_Enum_Enum_ARRAYSIZE = 14 + 1;
const ::google::protobuf::EnumDescriptor*
DeviceType_Enum_descriptor();
template <typename T>
const std::string& DeviceType_Enum_Name(T value) {
  static_assert(std::is_same<T, DeviceType_Enum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Enum_Name().");
  return DeviceType_Enum_Name(static_cast<DeviceType_Enum>(value));
}
template <>
inline const std::string& DeviceType_Enum_Name(DeviceType_Enum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DeviceType_Enum_descriptor,
                                                 0, 14>(
      static_cast<int>(value));
}
inline bool DeviceType_Enum_Parse(absl::string_view name, DeviceType_Enum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceType_Enum>(
      DeviceType_Enum_descriptor(), name, value);
}
enum UseCase_ActorType_Enum : int {
  UseCase_ActorType_Enum_UNKNOWN = 0,
  UseCase_ActorType_Enum_Battery = 1,
  UseCase_ActorType_Enum_BatterySystem = 2,
  UseCase_ActorType_Enum_CEM = 3,
  UseCase_ActorType_Enum_ConfigurationAppliance = 4,
  UseCase_ActorType_Enum_Compressor = 5,
  UseCase_ActorType_Enum_ControllableSystem = 6,
  UseCase_ActorType_Enum_DHWCircuit = 7,
  UseCase_ActorType_Enum_EnergyBroker = 8,
  UseCase_ActorType_Enum_EnergyConsumer = 9,
  UseCase_ActorType_Enum_EnergyGuard = 10,
  UseCase_ActorType_Enum_EVSE = 11,
  UseCase_ActorType_Enum_EV = 12,
  UseCase_ActorType_Enum_GridConnectionPoint = 13,
  UseCase_ActorType_Enum_HeatPump = 14,
  UseCase_ActorType_Enum_HeatingCircuit = 15,
  UseCase_ActorType_Enum_HeatingZone = 16,
  UseCase_ActorType_Enum_HVACRoom = 17,
  UseCase_ActorType_Enum_Inverter = 18,
  UseCase_ActorType_Enum_MonitoredUnit = 19,
  UseCase_ActorType_Enum_MonitoringAppliance = 20,
  UseCase_ActorType_Enum_OutdoorTemperatureSensor = 21,
  UseCase_ActorType_Enum_PVString = 22,
  UseCase_ActorType_Enum_PVSystem = 23,
  UseCase_ActorType_Enum_SmartAppliance = 24,
  UseCase_ActorType_Enum_VisualizationAppliance = 25,
  UseCase_ActorType_Enum_UseCase_ActorType_Enum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UseCase_ActorType_Enum_UseCase_ActorType_Enum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UseCase_ActorType_Enum_IsValid(int value);
extern const uint32_t UseCase_ActorType_Enum_internal_data_[];
constexpr UseCase_ActorType_Enum UseCase_ActorType_Enum_Enum_MIN = static_cast<UseCase_ActorType_Enum>(0);
constexpr UseCase_ActorType_Enum UseCase_ActorType_Enum_Enum_MAX = static_cast<UseCase_ActorType_Enum>(25);
constexpr int UseCase_ActorType_Enum_Enum_ARRAYSIZE = 25 + 1;
const ::google::protobuf::EnumDescriptor*
UseCase_ActorType_Enum_descriptor();
template <typename T>
const std::string& UseCase_ActorType_Enum_Name(T value) {
  static_assert(std::is_same<T, UseCase_ActorType_Enum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Enum_Name().");
  return UseCase_ActorType_Enum_Name(static_cast<UseCase_ActorType_Enum>(value));
}
template <>
inline const std::string& UseCase_ActorType_Enum_Name(UseCase_ActorType_Enum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UseCase_ActorType_Enum_descriptor,
                                                 0, 25>(
      static_cast<int>(value));
}
inline bool UseCase_ActorType_Enum_Parse(absl::string_view name, UseCase_ActorType_Enum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UseCase_ActorType_Enum>(
      UseCase_ActorType_Enum_descriptor(), name, value);
}
enum UseCase_NameType_Enum : int {
  UseCase_NameType_Enum_UNKNOWN = 0,
  UseCase_NameType_Enum_configurationOfDhwSystemFunction = 1,
  UseCase_NameType_Enum_configurationOfDhwTemperature = 2,
  UseCase_NameType_Enum_configurationOfRoomCoolingSystemFunction = 3,
  UseCase_NameType_Enum_configurationOfRoomCoolingTemperature = 4,
  UseCase_NameType_Enum_configurationOfRoomHeatingSystemFunction = 5,
  UseCase_NameType_Enum_configurationOfRoomHeatingTemperature = 6,
  UseCase_NameType_Enum_controlOfBattery = 7,
  UseCase_NameType_Enum_coordinatedEvCharging = 8,
  UseCase_NameType_Enum_evChargingSummary = 9,
  UseCase_NameType_Enum_evCommissioningAndConfiguration = 10,
  UseCase_NameType_Enum_evseCommissioningAndConfiguration = 11,
  UseCase_NameType_Enum_evStateOfCharge = 12,
  UseCase_NameType_Enum_flexibleLoad = 13,
  UseCase_NameType_Enum_flexibleStartForWhiteGoods = 14,
  UseCase_NameType_Enum_limitationOfPowerConsumption = 15,
  UseCase_NameType_Enum_limitationOfPowerProduction = 16,
  UseCase_NameType_Enum_incentiveTableBasedPowerConsumptionManagement = 17,
  UseCase_NameType_Enum_measurementOfElectricityDuringEvCharging = 18,
  UseCase_NameType_Enum_monitoringAndControlOfSmartGridReadyConditions = 19,
  UseCase_NameType_Enum_monitoringOfBattery = 20,
  UseCase_NameType_Enum_monitoringOfDhwSystemFunction = 21,
  UseCase_NameType_Enum_monitoringOfDhwTemperature = 22,
  UseCase_NameType_Enum_monitoringOfGridConnectionPoint = 23,
  UseCase_NameType_Enum_monitoringOfInverter = 24,
  UseCase_NameType_Enum_monitoringOfOutdoorTemperature = 25,
  UseCase_NameType_Enum_monitoringOfPowerConsumption = 26,
  UseCase_NameType_Enum_monitoringOfPvString = 27,
  UseCase_NameType_Enum_monitoringOfRoomCoolingSystemFunction = 28,
  UseCase_NameType_Enum_monitoringOfRoomHeatingSystemFunction = 29,
  UseCase_NameType_Enum_monitoringOfRoomTemperature = 30,
  UseCase_NameType_Enum_optimizationOfSelfConsumptionByHeatPumpCompressorFlexibility = 31,
  UseCase_NameType_Enum_optimizationOfSelfConsumptionDuringEvCharging = 32,
  UseCase_NameType_Enum_overloadProtectionByEvChargingCurrentCurtailment = 33,
  UseCase_NameType_Enum_visualizationOfAggregatedBatteryData = 34,
  UseCase_NameType_Enum_visualizationOfAggregatedPhotovoltaicData = 35,
  UseCase_NameType_Enum_visualizationOfHeatingAreaName = 36,
  UseCase_NameType_Enum_UseCase_NameType_Enum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UseCase_NameType_Enum_UseCase_NameType_Enum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UseCase_NameType_Enum_IsValid(int value);
extern const uint32_t UseCase_NameType_Enum_internal_data_[];
constexpr UseCase_NameType_Enum UseCase_NameType_Enum_Enum_MIN = static_cast<UseCase_NameType_Enum>(0);
constexpr UseCase_NameType_Enum UseCase_NameType_Enum_Enum_MAX = static_cast<UseCase_NameType_Enum>(36);
constexpr int UseCase_NameType_Enum_Enum_ARRAYSIZE = 36 + 1;
const ::google::protobuf::EnumDescriptor*
UseCase_NameType_Enum_descriptor();
template <typename T>
const std::string& UseCase_NameType_Enum_Name(T value) {
  static_assert(std::is_same<T, UseCase_NameType_Enum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Enum_Name().");
  return UseCase_NameType_Enum_Name(static_cast<UseCase_NameType_Enum>(value));
}
template <>
inline const std::string& UseCase_NameType_Enum_Name(UseCase_NameType_Enum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UseCase_NameType_Enum_descriptor,
                                                 0, 36>(
      static_cast<int>(value));
}
inline bool UseCase_NameType_Enum_Parse(absl::string_view name, UseCase_NameType_Enum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UseCase_NameType_Enum>(
      UseCase_NameType_Enum_descriptor(), name, value);
}
enum SharedType : int {
  INVERTER = 0,
  SharedType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SharedType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SharedType_IsValid(int value);
extern const uint32_t SharedType_internal_data_[];
constexpr SharedType SharedType_MIN = static_cast<SharedType>(0);
constexpr SharedType SharedType_MAX = static_cast<SharedType>(0);
constexpr int SharedType_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor*
SharedType_descriptor();
template <typename T>
const std::string& SharedType_Name(T value) {
  static_assert(std::is_same<T, SharedType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SharedType_Name().");
  return SharedType_Name(static_cast<SharedType>(value));
}
template <>
inline const std::string& SharedType_Name(SharedType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SharedType_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool SharedType_Parse(absl::string_view name, SharedType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SharedType>(
      SharedType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UseCase_NameType final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:control_service.UseCase.NameType) */ {
 public:
  inline UseCase_NameType() : UseCase_NameType(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UseCase_NameType(
      ::google::protobuf::internal::ConstantInitialized);

  inline UseCase_NameType(const UseCase_NameType& from) : UseCase_NameType(nullptr, from) {}
  inline UseCase_NameType(UseCase_NameType&& from) noexcept
      : UseCase_NameType(nullptr, std::move(from)) {}
  inline UseCase_NameType& operator=(const UseCase_NameType& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseCase_NameType& operator=(UseCase_NameType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseCase_NameType& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseCase_NameType* internal_default_instance() {
    return reinterpret_cast<const UseCase_NameType*>(
        &_UseCase_NameType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(UseCase_NameType& a, UseCase_NameType& b) { a.Swap(&b); }
  inline void Swap(UseCase_NameType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseCase_NameType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseCase_NameType* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<UseCase_NameType>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UseCase_NameType& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UseCase_NameType& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control_service.UseCase.NameType"; }

 protected:
  explicit UseCase_NameType(::google::protobuf::Arena* arena);
  UseCase_NameType(::google::protobuf::Arena* arena, const UseCase_NameType& from);
  UseCase_NameType(::google::protobuf::Arena* arena, UseCase_NameType&& from) noexcept
      : UseCase_NameType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Enum = UseCase_NameType_Enum;
  static constexpr Enum UNKNOWN = UseCase_NameType_Enum_UNKNOWN;
  static constexpr Enum configurationOfDhwSystemFunction = UseCase_NameType_Enum_configurationOfDhwSystemFunction;
  static constexpr Enum configurationOfDhwTemperature = UseCase_NameType_Enum_configurationOfDhwTemperature;
  static constexpr Enum configurationOfRoomCoolingSystemFunction = UseCase_NameType_Enum_configurationOfRoomCoolingSystemFunction;
  static constexpr Enum configurationOfRoomCoolingTemperature = UseCase_NameType_Enum_configurationOfRoomCoolingTemperature;
  static constexpr Enum configurationOfRoomHeatingSystemFunction = UseCase_NameType_Enum_configurationOfRoomHeatingSystemFunction;
  static constexpr Enum configurationOfRoomHeatingTemperature = UseCase_NameType_Enum_configurationOfRoomHeatingTemperature;
  static constexpr Enum controlOfBattery = UseCase_NameType_Enum_controlOfBattery;
  static constexpr Enum coordinatedEvCharging = UseCase_NameType_Enum_coordinatedEvCharging;
  static constexpr Enum evChargingSummary = UseCase_NameType_Enum_evChargingSummary;
  static constexpr Enum evCommissioningAndConfiguration = UseCase_NameType_Enum_evCommissioningAndConfiguration;
  static constexpr Enum evseCommissioningAndConfiguration = UseCase_NameType_Enum_evseCommissioningAndConfiguration;
  static constexpr Enum evStateOfCharge = UseCase_NameType_Enum_evStateOfCharge;
  static constexpr Enum flexibleLoad = UseCase_NameType_Enum_flexibleLoad;
  static constexpr Enum flexibleStartForWhiteGoods = UseCase_NameType_Enum_flexibleStartForWhiteGoods;
  static constexpr Enum limitationOfPowerConsumption = UseCase_NameType_Enum_limitationOfPowerConsumption;
  static constexpr Enum limitationOfPowerProduction = UseCase_NameType_Enum_limitationOfPowerProduction;
  static constexpr Enum incentiveTableBasedPowerConsumptionManagement = UseCase_NameType_Enum_incentiveTableBasedPowerConsumptionManagement;
  static constexpr Enum measurementOfElectricityDuringEvCharging = UseCase_NameType_Enum_measurementOfElectricityDuringEvCharging;
  static constexpr Enum monitoringAndControlOfSmartGridReadyConditions = UseCase_NameType_Enum_monitoringAndControlOfSmartGridReadyConditions;
  static constexpr Enum monitoringOfBattery = UseCase_NameType_Enum_monitoringOfBattery;
  static constexpr Enum monitoringOfDhwSystemFunction = UseCase_NameType_Enum_monitoringOfDhwSystemFunction;
  static constexpr Enum monitoringOfDhwTemperature = UseCase_NameType_Enum_monitoringOfDhwTemperature;
  static constexpr Enum monitoringOfGridConnectionPoint = UseCase_NameType_Enum_monitoringOfGridConnectionPoint;
  static constexpr Enum monitoringOfInverter = UseCase_NameType_Enum_monitoringOfInverter;
  static constexpr Enum monitoringOfOutdoorTemperature = UseCase_NameType_Enum_monitoringOfOutdoorTemperature;
  static constexpr Enum monitoringOfPowerConsumption = UseCase_NameType_Enum_monitoringOfPowerConsumption;
  static constexpr Enum monitoringOfPvString = UseCase_NameType_Enum_monitoringOfPvString;
  static constexpr Enum monitoringOfRoomCoolingSystemFunction = UseCase_NameType_Enum_monitoringOfRoomCoolingSystemFunction;
  static constexpr Enum monitoringOfRoomHeatingSystemFunction = UseCase_NameType_Enum_monitoringOfRoomHeatingSystemFunction;
  static constexpr Enum monitoringOfRoomTemperature = UseCase_NameType_Enum_monitoringOfRoomTemperature;
  static constexpr Enum optimizationOfSelfConsumptionByHeatPumpCompressorFlexibility = UseCase_NameType_Enum_optimizationOfSelfConsumptionByHeatPumpCompressorFlexibility;
  static constexpr Enum optimizationOfSelfConsumptionDuringEvCharging = UseCase_NameType_Enum_optimizationOfSelfConsumptionDuringEvCharging;
  static constexpr Enum overloadProtectionByEvChargingCurrentCurtailment = UseCase_NameType_Enum_overloadProtectionByEvChargingCurrentCurtailment;
  static constexpr Enum visualizationOfAggregatedBatteryData = UseCase_NameType_Enum_visualizationOfAggregatedBatteryData;
  static constexpr Enum visualizationOfAggregatedPhotovoltaicData = UseCase_NameType_Enum_visualizationOfAggregatedPhotovoltaicData;
  static constexpr Enum visualizationOfHeatingAreaName = UseCase_NameType_Enum_visualizationOfHeatingAreaName;
  static inline bool Enum_IsValid(int value) {
    return UseCase_NameType_Enum_IsValid(value);
  }
  static constexpr Enum Enum_MIN = UseCase_NameType_Enum_Enum_MIN;
  static constexpr Enum Enum_MAX = UseCase_NameType_Enum_Enum_MAX;
  static constexpr int Enum_ARRAYSIZE = UseCase_NameType_Enum_Enum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Enum_descriptor() {
    return UseCase_NameType_Enum_descriptor();
  }
  template <typename T>
  static inline const std::string& Enum_Name(T value) {
    return UseCase_NameType_Enum_Name(value);
  }
  static inline bool Enum_Parse(absl::string_view name, Enum* value) {
    return UseCase_NameType_Enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:control_service.UseCase.NameType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UseCase_NameType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UseCase_NameType& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_control_5fservice_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class UseCase_ActorType final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:control_service.UseCase.ActorType) */ {
 public:
  inline UseCase_ActorType() : UseCase_ActorType(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UseCase_ActorType(
      ::google::protobuf::internal::ConstantInitialized);

  inline UseCase_ActorType(const UseCase_ActorType& from) : UseCase_ActorType(nullptr, from) {}
  inline UseCase_ActorType(UseCase_ActorType&& from) noexcept
      : UseCase_ActorType(nullptr, std::move(from)) {}
  inline UseCase_ActorType& operator=(const UseCase_ActorType& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseCase_ActorType& operator=(UseCase_ActorType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseCase_ActorType& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseCase_ActorType* internal_default_instance() {
    return reinterpret_cast<const UseCase_ActorType*>(
        &_UseCase_ActorType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(UseCase_ActorType& a, UseCase_ActorType& b) { a.Swap(&b); }
  inline void Swap(UseCase_ActorType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseCase_ActorType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseCase_ActorType* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<UseCase_ActorType>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UseCase_ActorType& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UseCase_ActorType& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control_service.UseCase.ActorType"; }

 protected:
  explicit UseCase_ActorType(::google::protobuf::Arena* arena);
  UseCase_ActorType(::google::protobuf::Arena* arena, const UseCase_ActorType& from);
  UseCase_ActorType(::google::protobuf::Arena* arena, UseCase_ActorType&& from) noexcept
      : UseCase_ActorType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Enum = UseCase_ActorType_Enum;
  static constexpr Enum UNKNOWN = UseCase_ActorType_Enum_UNKNOWN;
  static constexpr Enum Battery = UseCase_ActorType_Enum_Battery;
  static constexpr Enum BatterySystem = UseCase_ActorType_Enum_BatterySystem;
  static constexpr Enum CEM = UseCase_ActorType_Enum_CEM;
  static constexpr Enum ConfigurationAppliance = UseCase_ActorType_Enum_ConfigurationAppliance;
  static constexpr Enum Compressor = UseCase_ActorType_Enum_Compressor;
  static constexpr Enum ControllableSystem = UseCase_ActorType_Enum_ControllableSystem;
  static constexpr Enum DHWCircuit = UseCase_ActorType_Enum_DHWCircuit;
  static constexpr Enum EnergyBroker = UseCase_ActorType_Enum_EnergyBroker;
  static constexpr Enum EnergyConsumer = UseCase_ActorType_Enum_EnergyConsumer;
  static constexpr Enum EnergyGuard = UseCase_ActorType_Enum_EnergyGuard;
  static constexpr Enum EVSE = UseCase_ActorType_Enum_EVSE;
  static constexpr Enum EV = UseCase_ActorType_Enum_EV;
  static constexpr Enum GridConnectionPoint = UseCase_ActorType_Enum_GridConnectionPoint;
  static constexpr Enum HeatPump = UseCase_ActorType_Enum_HeatPump;
  static constexpr Enum HeatingCircuit = UseCase_ActorType_Enum_HeatingCircuit;
  static constexpr Enum HeatingZone = UseCase_ActorType_Enum_HeatingZone;
  static constexpr Enum HVACRoom = UseCase_ActorType_Enum_HVACRoom;
  static constexpr Enum Inverter = UseCase_ActorType_Enum_Inverter;
  static constexpr Enum MonitoredUnit = UseCase_ActorType_Enum_MonitoredUnit;
  static constexpr Enum MonitoringAppliance = UseCase_ActorType_Enum_MonitoringAppliance;
  static constexpr Enum OutdoorTemperatureSensor = UseCase_ActorType_Enum_OutdoorTemperatureSensor;
  static constexpr Enum PVString = UseCase_ActorType_Enum_PVString;
  static constexpr Enum PVSystem = UseCase_ActorType_Enum_PVSystem;
  static constexpr Enum SmartAppliance = UseCase_ActorType_Enum_SmartAppliance;
  static constexpr Enum VisualizationAppliance = UseCase_ActorType_Enum_VisualizationAppliance;
  static inline bool Enum_IsValid(int value) {
    return UseCase_ActorType_Enum_IsValid(value);
  }
  static constexpr Enum Enum_MIN = UseCase_ActorType_Enum_Enum_MIN;
  static constexpr Enum Enum_MAX = UseCase_ActorType_Enum_Enum_MAX;
  static constexpr int Enum_ARRAYSIZE = UseCase_ActorType_Enum_Enum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Enum_descriptor() {
    return UseCase_ActorType_Enum_descriptor();
  }
  template <typename T>
  static inline const std::string& Enum_Name(T value) {
    return UseCase_ActorType_Enum_Name(value);
  }
  static inline bool Enum_Parse(absl::string_view name, Enum* value) {
    return UseCase_ActorType_Enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:control_service.UseCase.ActorType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UseCase_ActorType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UseCase_ActorType& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_control_5fservice_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class UseCase final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control_service.UseCase) */ {
 public:
  inline UseCase() : UseCase(nullptr) {}
  ~UseCase() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UseCase(
      ::google::protobuf::internal::ConstantInitialized);

  inline UseCase(const UseCase& from) : UseCase(nullptr, from) {}
  inline UseCase(UseCase&& from) noexcept
      : UseCase(nullptr, std::move(from)) {}
  inline UseCase& operator=(const UseCase& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseCase& operator=(UseCase&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseCase& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseCase* internal_default_instance() {
    return reinterpret_cast<const UseCase*>(
        &_UseCase_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(UseCase& a, UseCase& b) { a.Swap(&b); }
  inline void Swap(UseCase* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseCase* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseCase* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UseCase>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UseCase& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UseCase& from) { UseCase::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UseCase* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control_service.UseCase"; }

 protected:
  explicit UseCase(::google::protobuf::Arena* arena);
  UseCase(::google::protobuf::Arena* arena, const UseCase& from);
  UseCase(::google::protobuf::Arena* arena, UseCase&& from) noexcept
      : UseCase(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ActorType = UseCase_ActorType;
  using NameType = UseCase_NameType;

  // accessors -------------------------------------------------------
  enum : int {
    kActorFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // .control_service.UseCase.ActorType.Enum actor = 1;
  void clear_actor() ;
  ::control_service::UseCase_ActorType_Enum actor() const;
  void set_actor(::control_service::UseCase_ActorType_Enum value);

  private:
  ::control_service::UseCase_ActorType_Enum _internal_actor() const;
  void _internal_set_actor(::control_service::UseCase_ActorType_Enum value);

  public:
  // .control_service.UseCase.NameType.Enum name = 2;
  void clear_name() ;
  ::control_service::UseCase_NameType_Enum name() const;
  void set_name(::control_service::UseCase_NameType_Enum value);

  private:
  ::control_service::UseCase_NameType_Enum _internal_name() const;
  void _internal_set_name(::control_service::UseCase_NameType_Enum value);

  public:
  // @@protoc_insertion_point(class_scope:control_service.UseCase)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UseCase_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UseCase& from_msg);
    int actor_;
    int name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_control_5fservice_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class EntityType final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:control_service.EntityType) */ {
 public:
  inline EntityType() : EntityType(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntityType(
      ::google::protobuf::internal::ConstantInitialized);

  inline EntityType(const EntityType& from) : EntityType(nullptr, from) {}
  inline EntityType(EntityType&& from) noexcept
      : EntityType(nullptr, std::move(from)) {}
  inline EntityType& operator=(const EntityType& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityType& operator=(EntityType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityType& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityType* internal_default_instance() {
    return reinterpret_cast<const EntityType*>(
        &_EntityType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(EntityType& a, EntityType& b) { a.Swap(&b); }
  inline void Swap(EntityType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityType* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<EntityType>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EntityType& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EntityType& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control_service.EntityType"; }

 protected:
  explicit EntityType(::google::protobuf::Arena* arena);
  EntityType(::google::protobuf::Arena* arena, const EntityType& from);
  EntityType(::google::protobuf::Arena* arena, EntityType&& from) noexcept
      : EntityType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Enum = EntityType_Enum;
  static constexpr Enum UNKNOWN = EntityType_Enum_UNKNOWN;
  static constexpr Enum Battery = EntityType_Enum_Battery;
  static constexpr Enum Compressor = EntityType_Enum_Compressor;
  static constexpr Enum DeviceInformation = EntityType_Enum_DeviceInformation;
  static constexpr Enum DHWCircuit = EntityType_Enum_DHWCircuit;
  static constexpr Enum DHWStorage = EntityType_Enum_DHWStorage;
  static constexpr Enum Dishwasher = EntityType_Enum_Dishwasher;
  static constexpr Enum Dryer = EntityType_Enum_Dryer;
  static constexpr Enum ElectricalImmersionHeater = EntityType_Enum_ElectricalImmersionHeater;
  static constexpr Enum Fan = EntityType_Enum_Fan;
  static constexpr Enum GasHeatingAppliance = EntityType_Enum_GasHeatingAppliance;
  static constexpr Enum Generic = EntityType_Enum_Generic;
  static constexpr Enum HeatingBufferStorage = EntityType_Enum_HeatingBufferStorage;
  static constexpr Enum HeatingCircuit = EntityType_Enum_HeatingCircuit;
  static constexpr Enum HeatingObject = EntityType_Enum_HeatingObject;
  static constexpr Enum HeatingZone = EntityType_Enum_HeatingZone;
  static constexpr Enum HeatPumpAppliance = EntityType_Enum_HeatPumpAppliance;
  static constexpr Enum HeatSinkCircuit = EntityType_Enum_HeatSinkCircuit;
  static constexpr Enum HeatSourceCircuit = EntityType_Enum_HeatSourceCircuit;
  static constexpr Enum HeatSourceUnit = EntityType_Enum_HeatSourceUnit;
  static constexpr Enum HvacController = EntityType_Enum_HvacController;
  static constexpr Enum HvacRoom = EntityType_Enum_HvacRoom;
  static constexpr Enum InstantDHWHeater = EntityType_Enum_InstantDHWHeater;
  static constexpr Enum Inverter = EntityType_Enum_Inverter;
  static constexpr Enum OilHeatingAppliance = EntityType_Enum_OilHeatingAppliance;
  static constexpr Enum Pump = EntityType_Enum_Pump;
  static constexpr Enum RefrigerantCircuit = EntityType_Enum_RefrigerantCircuit;
  static constexpr Enum SmartEnergyAppliance = EntityType_Enum_SmartEnergyAppliance;
  static constexpr Enum SolarDHWStorage = EntityType_Enum_SolarDHWStorage;
  static constexpr Enum SolarThermalCircuit = EntityType_Enum_SolarThermalCircuit;
  static constexpr Enum SubMeterElectricity = EntityType_Enum_SubMeterElectricity;
  static constexpr Enum TemperatureSensor = EntityType_Enum_TemperatureSensor;
  static constexpr Enum Washer = EntityType_Enum_Washer;
  static constexpr Enum BatterySystem = EntityType_Enum_BatterySystem;
  static constexpr Enum ElectricityGenerationSystem = EntityType_Enum_ElectricityGenerationSystem;
  static constexpr Enum ElectricityStorageSystem = EntityType_Enum_ElectricityStorageSystem;
  static constexpr Enum GridConnectionPointOfPremises = EntityType_Enum_GridConnectionPointOfPremises;
  static constexpr Enum Household = EntityType_Enum_Household;
  static constexpr Enum PVSystem = EntityType_Enum_PVSystem;
  static constexpr Enum EV = EntityType_Enum_EV;
  static constexpr Enum EVSE = EntityType_Enum_EVSE;
  static constexpr Enum ChargingOutlet = EntityType_Enum_ChargingOutlet;
  static constexpr Enum CEM = EntityType_Enum_CEM;
  static constexpr Enum PV = EntityType_Enum_PV;
  static constexpr Enum PVESHybrid = EntityType_Enum_PVESHybrid;
  static constexpr Enum ElectricalStorage = EntityType_Enum_ElectricalStorage;
  static constexpr Enum PVString = EntityType_Enum_PVString;
  static constexpr Enum GridGuard = EntityType_Enum_GridGuard;
  static constexpr Enum ControllableSystem = EntityType_Enum_ControllableSystem;
  static inline bool Enum_IsValid(int value) {
    return EntityType_Enum_IsValid(value);
  }
  static constexpr Enum Enum_MIN = EntityType_Enum_Enum_MIN;
  static constexpr Enum Enum_MAX = EntityType_Enum_Enum_MAX;
  static constexpr int Enum_ARRAYSIZE = EntityType_Enum_Enum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Enum_descriptor() {
    return EntityType_Enum_descriptor();
  }
  template <typename T>
  static inline const std::string& Enum_Name(T value) {
    return EntityType_Enum_Name(value);
  }
  static inline bool Enum_Parse(absl::string_view name, Enum* value) {
    return EntityType_Enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:control_service.EntityType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EntityType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EntityType& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_control_5fservice_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class DeviceType final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:control_service.DeviceType) */ {
 public:
  inline DeviceType() : DeviceType(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceType(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeviceType(const DeviceType& from) : DeviceType(nullptr, from) {}
  inline DeviceType(DeviceType&& from) noexcept
      : DeviceType(nullptr, std::move(from)) {}
  inline DeviceType& operator=(const DeviceType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceType& operator=(DeviceType&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceType& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceType* internal_default_instance() {
    return reinterpret_cast<const DeviceType*>(
        &_DeviceType_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(DeviceType& a, DeviceType& b) { a.Swap(&b); }
  inline void Swap(DeviceType* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceType* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceType* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DeviceType>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeviceType& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeviceType& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control_service.DeviceType"; }

 protected:
  explicit DeviceType(::google::protobuf::Arena* arena);
  DeviceType(::google::protobuf::Arena* arena, const DeviceType& from);
  DeviceType(::google::protobuf::Arena* arena, DeviceType&& from) noexcept
      : DeviceType(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Enum = DeviceType_Enum;
  static constexpr Enum UNKNOWN = DeviceType_Enum_UNKNOWN;
  static constexpr Enum DISHWASHER = DeviceType_Enum_DISHWASHER;
  static constexpr Enum DRYER = DeviceType_Enum_DRYER;
  static constexpr Enum ENVIRONMENT_SENSOR = DeviceType_Enum_ENVIRONMENT_SENSOR;
  static constexpr Enum GENERIC = DeviceType_Enum_GENERIC;
  static constexpr Enum HEAT_GENERATION_SYSTEM = DeviceType_Enum_HEAT_GENERATION_SYSTEM;
  static constexpr Enum HEAT_SINK_SYSTEM = DeviceType_Enum_HEAT_SINK_SYSTEM;
  static constexpr Enum HEAT_STORAGE_SYSTEM = DeviceType_Enum_HEAT_STORAGE_SYSTEM;
  static constexpr Enum HVAC_CONTROLLER = DeviceType_Enum_HVAC_CONTROLLER;
  static constexpr Enum SUBMETER = DeviceType_Enum_SUBMETER;
  static constexpr Enum WASHER = DeviceType_Enum_WASHER;
  static constexpr Enum ELECTRICITY_SUPPLY_SYSTEM = DeviceType_Enum_ELECTRICITY_SUPPLY_SYSTEM;
  static constexpr Enum ENERGY_MANAGEMENT_SYSTEM = DeviceType_Enum_ENERGY_MANAGEMENT_SYSTEM;
  static constexpr Enum INVERTER = DeviceType_Enum_INVERTER;
  static constexpr Enum CHARGING_STATION = DeviceType_Enum_CHARGING_STATION;
  static inline bool Enum_IsValid(int value) {
    return DeviceType_Enum_IsValid(value);
  }
  static constexpr Enum Enum_MIN = DeviceType_Enum_Enum_MIN;
  static constexpr Enum Enum_MAX = DeviceType_Enum_Enum_MAX;
  static constexpr int Enum_ARRAYSIZE = DeviceType_Enum_Enum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Enum_descriptor() {
    return DeviceType_Enum_descriptor();
  }
  template <typename T>
  static inline const std::string& Enum_Name(T value) {
    return DeviceType_Enum_Name(value);
  }
  static inline bool Enum_Parse(absl::string_view name, Enum* value) {
    return DeviceType_Enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:control_service.DeviceType)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DeviceType_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeviceType& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_control_5fservice_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class DeviceCategory final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:control_service.DeviceCategory) */ {
 public:
  inline DeviceCategory() : DeviceCategory(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeviceCategory(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeviceCategory(const DeviceCategory& from) : DeviceCategory(nullptr, from) {}
  inline DeviceCategory(DeviceCategory&& from) noexcept
      : DeviceCategory(nullptr, std::move(from)) {}
  inline DeviceCategory& operator=(const DeviceCategory& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceCategory& operator=(DeviceCategory&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceCategory& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceCategory* internal_default_instance() {
    return reinterpret_cast<const DeviceCategory*>(
        &_DeviceCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(DeviceCategory& a, DeviceCategory& b) { a.Swap(&b); }
  inline void Swap(DeviceCategory* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceCategory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceCategory* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<DeviceCategory>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeviceCategory& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeviceCategory& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control_service.DeviceCategory"; }

 protected:
  explicit DeviceCategory(::google::protobuf::Arena* arena);
  DeviceCategory(::google::protobuf::Arena* arena, const DeviceCategory& from);
  DeviceCategory(::google::protobuf::Arena* arena, DeviceCategory&& from) noexcept
      : DeviceCategory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Enum = DeviceCategory_Enum;
  static constexpr Enum UNKNOWN = DeviceCategory_Enum_UNKNOWN;
  static constexpr Enum GRID_CONNECTION_HUB = DeviceCategory_Enum_GRID_CONNECTION_HUB;
  static constexpr Enum ENERGY_MANAGEMENT_SYSTEM = DeviceCategory_Enum_ENERGY_MANAGEMENT_SYSTEM;
  static constexpr Enum E_MOBILITY = DeviceCategory_Enum_E_MOBILITY;
  static constexpr Enum HVAC = DeviceCategory_Enum_HVAC;
  static constexpr Enum INVERTER = DeviceCategory_Enum_INVERTER;
  static constexpr Enum DOMESTIC_APPLIANCE = DeviceCategory_Enum_DOMESTIC_APPLIANCE;
  static constexpr Enum METERING = DeviceCategory_Enum_METERING;
  static inline bool Enum_IsValid(int value) {
    return DeviceCategory_Enum_IsValid(value);
  }
  static constexpr Enum Enum_MIN = DeviceCategory_Enum_Enum_MIN;
  static constexpr Enum Enum_MAX = DeviceCategory_Enum_Enum_MAX;
  static constexpr int Enum_ARRAYSIZE = DeviceCategory_Enum_Enum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Enum_descriptor() {
    return DeviceCategory_Enum_descriptor();
  }
  template <typename T>
  static inline const std::string& Enum_Name(T value) {
    return DeviceCategory_Enum_Name(value);
  }
  static inline bool Enum_Parse(absl::string_view name, Enum* value) {
    return DeviceCategory_Enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:control_service.DeviceCategory)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_DeviceCategory_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeviceCategory& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_control_5fservice_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class UseCaseEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:control_service.UseCaseEvent) */ {
 public:
  inline UseCaseEvent() : UseCaseEvent(nullptr) {}
  ~UseCaseEvent() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UseCaseEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline UseCaseEvent(const UseCaseEvent& from) : UseCaseEvent(nullptr, from) {}
  inline UseCaseEvent(UseCaseEvent&& from) noexcept
      : UseCaseEvent(nullptr, std::move(from)) {}
  inline UseCaseEvent& operator=(const UseCaseEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseCaseEvent& operator=(UseCaseEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseCaseEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseCaseEvent* internal_default_instance() {
    return reinterpret_cast<const UseCaseEvent*>(
        &_UseCaseEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(UseCaseEvent& a, UseCaseEvent& b) { a.Swap(&b); }
  inline void Swap(UseCaseEvent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseCaseEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseCaseEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UseCaseEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UseCaseEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UseCaseEvent& from) { UseCaseEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UseCaseEvent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "control_service.UseCaseEvent"; }

 protected:
  explicit UseCaseEvent(::google::protobuf::Arena* arena);
  UseCaseEvent(::google::protobuf::Arena* arena, const UseCaseEvent& from);
  UseCaseEvent(::google::protobuf::Arena* arena, UseCaseEvent&& from) noexcept
      : UseCaseEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventFieldNumber = 2,
    kUseCaseFieldNumber = 1,
  };
  // string event = 2;
  void clear_event() ;
  const std::string& event() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_event(Arg_&& arg, Args_... args);
  std::string* mutable_event();
  PROTOBUF_NODISCARD std::string* release_event();
  void set_allocated_event(std::string* value);

  private:
  const std::string& _internal_event() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event(
      const std::string& value);
  std::string* _internal_mutable_event();

  public:
  // .control_service.UseCase use_case = 1;
  bool has_use_case() const;
  void clear_use_case() ;
  const ::control_service::UseCase& use_case() const;
  PROTOBUF_NODISCARD ::control_service::UseCase* release_use_case();
  ::control_service::UseCase* mutable_use_case();
  void set_allocated_use_case(::control_service::UseCase* value);
  void unsafe_arena_set_allocated_use_case(::control_service::UseCase* value);
  ::control_service::UseCase* unsafe_arena_release_use_case();

  private:
  const ::control_service::UseCase& _internal_use_case() const;
  ::control_service::UseCase* _internal_mutable_use_case();

  public:
  // @@protoc_insertion_point(class_scope:control_service.UseCaseEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      42, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UseCaseEvent_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UseCaseEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr event_;
    ::control_service::UseCase* use_case_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_control_5fservice_2ftypes_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// DeviceCategory

// -------------------------------------------------------------------

// EntityType

// -------------------------------------------------------------------

// DeviceType

// -------------------------------------------------------------------

// UseCase_ActorType

// -------------------------------------------------------------------

// UseCase_NameType

// -------------------------------------------------------------------

// UseCase

// .control_service.UseCase.ActorType.Enum actor = 1;
inline void UseCase::clear_actor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actor_ = 0;
}
inline ::control_service::UseCase_ActorType_Enum UseCase::actor() const {
  // @@protoc_insertion_point(field_get:control_service.UseCase.actor)
  return _internal_actor();
}
inline void UseCase::set_actor(::control_service::UseCase_ActorType_Enum value) {
  _internal_set_actor(value);
  // @@protoc_insertion_point(field_set:control_service.UseCase.actor)
}
inline ::control_service::UseCase_ActorType_Enum UseCase::_internal_actor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::control_service::UseCase_ActorType_Enum>(_impl_.actor_);
}
inline void UseCase::_internal_set_actor(::control_service::UseCase_ActorType_Enum value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.actor_ = value;
}

// .control_service.UseCase.NameType.Enum name = 2;
inline void UseCase::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_ = 0;
}
inline ::control_service::UseCase_NameType_Enum UseCase::name() const {
  // @@protoc_insertion_point(field_get:control_service.UseCase.name)
  return _internal_name();
}
inline void UseCase::set_name(::control_service::UseCase_NameType_Enum value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:control_service.UseCase.name)
}
inline ::control_service::UseCase_NameType_Enum UseCase::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::control_service::UseCase_NameType_Enum>(_impl_.name_);
}
inline void UseCase::_internal_set_name(::control_service::UseCase_NameType_Enum value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_ = value;
}

// -------------------------------------------------------------------

// UseCaseEvent

// .control_service.UseCase use_case = 1;
inline bool UseCaseEvent::has_use_case() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.use_case_ != nullptr);
  return value;
}
inline void UseCaseEvent::clear_use_case() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.use_case_ != nullptr) _impl_.use_case_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::control_service::UseCase& UseCaseEvent::_internal_use_case() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::control_service::UseCase* p = _impl_.use_case_;
  return p != nullptr ? *p : reinterpret_cast<const ::control_service::UseCase&>(::control_service::_UseCase_default_instance_);
}
inline const ::control_service::UseCase& UseCaseEvent::use_case() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control_service.UseCaseEvent.use_case)
  return _internal_use_case();
}
inline void UseCaseEvent::unsafe_arena_set_allocated_use_case(::control_service::UseCase* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.use_case_);
  }
  _impl_.use_case_ = reinterpret_cast<::control_service::UseCase*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:control_service.UseCaseEvent.use_case)
}
inline ::control_service::UseCase* UseCaseEvent::release_use_case() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control_service::UseCase* released = _impl_.use_case_;
  _impl_.use_case_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::control_service::UseCase* UseCaseEvent::unsafe_arena_release_use_case() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control_service.UseCaseEvent.use_case)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::control_service::UseCase* temp = _impl_.use_case_;
  _impl_.use_case_ = nullptr;
  return temp;
}
inline ::control_service::UseCase* UseCaseEvent::_internal_mutable_use_case() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.use_case_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::control_service::UseCase>(GetArena());
    _impl_.use_case_ = reinterpret_cast<::control_service::UseCase*>(p);
  }
  return _impl_.use_case_;
}
inline ::control_service::UseCase* UseCaseEvent::mutable_use_case() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::control_service::UseCase* _msg = _internal_mutable_use_case();
  // @@protoc_insertion_point(field_mutable:control_service.UseCaseEvent.use_case)
  return _msg;
}
inline void UseCaseEvent::set_allocated_use_case(::control_service::UseCase* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.use_case_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.use_case_ = reinterpret_cast<::control_service::UseCase*>(value);
  // @@protoc_insertion_point(field_set_allocated:control_service.UseCaseEvent.use_case)
}

// string event = 2;
inline void UseCaseEvent::clear_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_.ClearToEmpty();
}
inline const std::string& UseCaseEvent::event() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:control_service.UseCaseEvent.event)
  return _internal_event();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UseCaseEvent::set_event(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:control_service.UseCaseEvent.event)
}
inline std::string* UseCaseEvent::mutable_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:control_service.UseCaseEvent.event)
  return _s;
}
inline const std::string& UseCaseEvent::_internal_event() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.event_.Get();
}
inline void UseCaseEvent::_internal_set_event(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_.Set(value, GetArena());
}
inline std::string* UseCaseEvent::_internal_mutable_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.event_.Mutable( GetArena());
}
inline std::string* UseCaseEvent::release_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:control_service.UseCaseEvent.event)
  return _impl_.event_.Release();
}
inline void UseCaseEvent::set_allocated_event(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.event_.IsDefault()) {
          _impl_.event_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:control_service.UseCaseEvent.event)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

DeviceCategory CreateDeviceCategory();

EntityType CreateEntityType();

DeviceType CreateDeviceType();

UseCase CreateUseCase(
    control_service::UseCase::ActorType::Enum actor,
    control_service::UseCase::NameType::Enum name);

UseCaseEvent CreateUseCaseEvent(
    control_service::UseCase* use_case,
    std::string event);

// @@protoc_insertion_point(namespace_scope)
}  // namespace control_service


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::control_service::DeviceCategory_Enum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control_service::DeviceCategory_Enum>() {
  return ::control_service::DeviceCategory_Enum_descriptor();
}
template <>
struct is_proto_enum<::control_service::EntityType_Enum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control_service::EntityType_Enum>() {
  return ::control_service::EntityType_Enum_descriptor();
}
template <>
struct is_proto_enum<::control_service::DeviceType_Enum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control_service::DeviceType_Enum>() {
  return ::control_service::DeviceType_Enum_descriptor();
}
template <>
struct is_proto_enum<::control_service::UseCase_ActorType_Enum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control_service::UseCase_ActorType_Enum>() {
  return ::control_service::UseCase_ActorType_Enum_descriptor();
}
template <>
struct is_proto_enum<::control_service::UseCase_NameType_Enum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control_service::UseCase_NameType_Enum>() {
  return ::control_service::UseCase_NameType_Enum_descriptor();
}
template <>
struct is_proto_enum<::control_service::SharedType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::control_service::SharedType>() {
  return ::control_service::SharedType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_control_5fservice_2ftypes_2eproto_2epb_2eh
