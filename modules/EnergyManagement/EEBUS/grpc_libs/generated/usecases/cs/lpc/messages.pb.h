// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: usecases/cs/lpc/messages.proto
// Protobuf C++ Version: 5.29.0

#ifndef usecases_2fcs_2flpc_2fmessages_2eproto_2epb_2eh
#define usecases_2fcs_2flpc_2fmessages_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/unknown_field_set.h"
#include "common_types/types.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_usecases_2fcs_2flpc_2fmessages_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_usecases_2fcs_2flpc_2fmessages_2eproto;
namespace cs_lpc {
class ApproveOrDenyConsumptionLimitRequest;
struct ApproveOrDenyConsumptionLimitRequestDefaultTypeInternal;
extern ApproveOrDenyConsumptionLimitRequestDefaultTypeInternal _ApproveOrDenyConsumptionLimitRequest_default_instance_;
class ApproveOrDenyConsumptionLimitResponse;
struct ApproveOrDenyConsumptionLimitResponseDefaultTypeInternal;
extern ApproveOrDenyConsumptionLimitResponseDefaultTypeInternal _ApproveOrDenyConsumptionLimitResponse_default_instance_;
class ConsumptionLimitRequest;
struct ConsumptionLimitRequestDefaultTypeInternal;
extern ConsumptionLimitRequestDefaultTypeInternal _ConsumptionLimitRequest_default_instance_;
class ConsumptionLimitResponse;
struct ConsumptionLimitResponseDefaultTypeInternal;
extern ConsumptionLimitResponseDefaultTypeInternal _ConsumptionLimitResponse_default_instance_;
class ConsumptionNominalMaxRequest;
struct ConsumptionNominalMaxRequestDefaultTypeInternal;
extern ConsumptionNominalMaxRequestDefaultTypeInternal _ConsumptionNominalMaxRequest_default_instance_;
class ConsumptionNominalMaxResponse;
struct ConsumptionNominalMaxResponseDefaultTypeInternal;
extern ConsumptionNominalMaxResponseDefaultTypeInternal _ConsumptionNominalMaxResponse_default_instance_;
class FailsafeConsumptionActivePowerLimitRequest;
struct FailsafeConsumptionActivePowerLimitRequestDefaultTypeInternal;
extern FailsafeConsumptionActivePowerLimitRequestDefaultTypeInternal _FailsafeConsumptionActivePowerLimitRequest_default_instance_;
class FailsafeConsumptionActivePowerLimitResponse;
struct FailsafeConsumptionActivePowerLimitResponseDefaultTypeInternal;
extern FailsafeConsumptionActivePowerLimitResponseDefaultTypeInternal _FailsafeConsumptionActivePowerLimitResponse_default_instance_;
class FailsafeDurationMinimumRequest;
struct FailsafeDurationMinimumRequestDefaultTypeInternal;
extern FailsafeDurationMinimumRequestDefaultTypeInternal _FailsafeDurationMinimumRequest_default_instance_;
class FailsafeDurationMinimumResponse;
struct FailsafeDurationMinimumResponseDefaultTypeInternal;
extern FailsafeDurationMinimumResponseDefaultTypeInternal _FailsafeDurationMinimumResponse_default_instance_;
class IsHeartbeatWithinDurationRequest;
struct IsHeartbeatWithinDurationRequestDefaultTypeInternal;
extern IsHeartbeatWithinDurationRequestDefaultTypeInternal _IsHeartbeatWithinDurationRequest_default_instance_;
class IsHeartbeatWithinDurationResponse;
struct IsHeartbeatWithinDurationResponseDefaultTypeInternal;
extern IsHeartbeatWithinDurationResponseDefaultTypeInternal _IsHeartbeatWithinDurationResponse_default_instance_;
class PendingConsumptionLimitRequest;
struct PendingConsumptionLimitRequestDefaultTypeInternal;
extern PendingConsumptionLimitRequestDefaultTypeInternal _PendingConsumptionLimitRequest_default_instance_;
class PendingConsumptionLimitResponse;
struct PendingConsumptionLimitResponseDefaultTypeInternal;
extern PendingConsumptionLimitResponseDefaultTypeInternal _PendingConsumptionLimitResponse_default_instance_;
class PendingConsumptionLimitResponse_LoadLimitsEntry_DoNotUse;
struct PendingConsumptionLimitResponse_LoadLimitsEntry_DoNotUseDefaultTypeInternal;
extern PendingConsumptionLimitResponse_LoadLimitsEntry_DoNotUseDefaultTypeInternal _PendingConsumptionLimitResponse_LoadLimitsEntry_DoNotUse_default_instance_;
class SetConsumptionLimitRequest;
struct SetConsumptionLimitRequestDefaultTypeInternal;
extern SetConsumptionLimitRequestDefaultTypeInternal _SetConsumptionLimitRequest_default_instance_;
class SetConsumptionLimitResponse;
struct SetConsumptionLimitResponseDefaultTypeInternal;
extern SetConsumptionLimitResponseDefaultTypeInternal _SetConsumptionLimitResponse_default_instance_;
class SetConsumptionNominalMaxRequest;
struct SetConsumptionNominalMaxRequestDefaultTypeInternal;
extern SetConsumptionNominalMaxRequestDefaultTypeInternal _SetConsumptionNominalMaxRequest_default_instance_;
class SetConsumptionNominalMaxResponse;
struct SetConsumptionNominalMaxResponseDefaultTypeInternal;
extern SetConsumptionNominalMaxResponseDefaultTypeInternal _SetConsumptionNominalMaxResponse_default_instance_;
class SetFailsafeConsumptionActivePowerLimitRequest;
struct SetFailsafeConsumptionActivePowerLimitRequestDefaultTypeInternal;
extern SetFailsafeConsumptionActivePowerLimitRequestDefaultTypeInternal _SetFailsafeConsumptionActivePowerLimitRequest_default_instance_;
class SetFailsafeConsumptionActivePowerLimitResponse;
struct SetFailsafeConsumptionActivePowerLimitResponseDefaultTypeInternal;
extern SetFailsafeConsumptionActivePowerLimitResponseDefaultTypeInternal _SetFailsafeConsumptionActivePowerLimitResponse_default_instance_;
class SetFailsafeDurationMinimumRequest;
struct SetFailsafeDurationMinimumRequestDefaultTypeInternal;
extern SetFailsafeDurationMinimumRequestDefaultTypeInternal _SetFailsafeDurationMinimumRequest_default_instance_;
class SetFailsafeDurationMinimumResponse;
struct SetFailsafeDurationMinimumResponseDefaultTypeInternal;
extern SetFailsafeDurationMinimumResponseDefaultTypeInternal _SetFailsafeDurationMinimumResponse_default_instance_;
class StartHeartbeatRequest;
struct StartHeartbeatRequestDefaultTypeInternal;
extern StartHeartbeatRequestDefaultTypeInternal _StartHeartbeatRequest_default_instance_;
class StartHeartbeatResponse;
struct StartHeartbeatResponseDefaultTypeInternal;
extern StartHeartbeatResponseDefaultTypeInternal _StartHeartbeatResponse_default_instance_;
class StopHeartbeatRequest;
struct StopHeartbeatRequestDefaultTypeInternal;
extern StopHeartbeatRequestDefaultTypeInternal _StopHeartbeatRequest_default_instance_;
class StopHeartbeatResponse;
struct StopHeartbeatResponseDefaultTypeInternal;
extern StopHeartbeatResponseDefaultTypeInternal _StopHeartbeatResponse_default_instance_;
}  // namespace cs_lpc
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace cs_lpc {

// ===================================================================


// -------------------------------------------------------------------

class StopHeartbeatResponse final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.StopHeartbeatResponse) */ {
 public:
  inline StopHeartbeatResponse() : StopHeartbeatResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StopHeartbeatResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StopHeartbeatResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StopHeartbeatResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline StopHeartbeatResponse(const StopHeartbeatResponse& from) : StopHeartbeatResponse(nullptr, from) {}
  inline StopHeartbeatResponse(StopHeartbeatResponse&& from) noexcept
      : StopHeartbeatResponse(nullptr, std::move(from)) {}
  inline StopHeartbeatResponse& operator=(const StopHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopHeartbeatResponse& operator=(StopHeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopHeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const StopHeartbeatResponse*>(
        &_StopHeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(StopHeartbeatResponse& a, StopHeartbeatResponse& b) { a.Swap(&b); }
  inline void Swap(StopHeartbeatResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopHeartbeatResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopHeartbeatResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<StopHeartbeatResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopHeartbeatResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopHeartbeatResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.StopHeartbeatResponse"; }

 protected:
  explicit StopHeartbeatResponse(::google::protobuf::Arena* arena);
  StopHeartbeatResponse(::google::protobuf::Arena* arena, const StopHeartbeatResponse& from);
  StopHeartbeatResponse(::google::protobuf::Arena* arena, StopHeartbeatResponse&& from) noexcept
      : StopHeartbeatResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.StopHeartbeatResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StopHeartbeatResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class StopHeartbeatRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.StopHeartbeatRequest) */ {
 public:
  inline StopHeartbeatRequest() : StopHeartbeatRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StopHeartbeatRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StopHeartbeatRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StopHeartbeatRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline StopHeartbeatRequest(const StopHeartbeatRequest& from) : StopHeartbeatRequest(nullptr, from) {}
  inline StopHeartbeatRequest(StopHeartbeatRequest&& from) noexcept
      : StopHeartbeatRequest(nullptr, std::move(from)) {}
  inline StopHeartbeatRequest& operator=(const StopHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopHeartbeatRequest& operator=(StopHeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopHeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const StopHeartbeatRequest*>(
        &_StopHeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(StopHeartbeatRequest& a, StopHeartbeatRequest& b) { a.Swap(&b); }
  inline void Swap(StopHeartbeatRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopHeartbeatRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopHeartbeatRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<StopHeartbeatRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopHeartbeatRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopHeartbeatRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.StopHeartbeatRequest"; }

 protected:
  explicit StopHeartbeatRequest(::google::protobuf::Arena* arena);
  StopHeartbeatRequest(::google::protobuf::Arena* arena, const StopHeartbeatRequest& from);
  StopHeartbeatRequest(::google::protobuf::Arena* arena, StopHeartbeatRequest&& from) noexcept
      : StopHeartbeatRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.StopHeartbeatRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StopHeartbeatRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class StartHeartbeatResponse final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.StartHeartbeatResponse) */ {
 public:
  inline StartHeartbeatResponse() : StartHeartbeatResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StartHeartbeatResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StartHeartbeatResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StartHeartbeatResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline StartHeartbeatResponse(const StartHeartbeatResponse& from) : StartHeartbeatResponse(nullptr, from) {}
  inline StartHeartbeatResponse(StartHeartbeatResponse&& from) noexcept
      : StartHeartbeatResponse(nullptr, std::move(from)) {}
  inline StartHeartbeatResponse& operator=(const StartHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartHeartbeatResponse& operator=(StartHeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartHeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const StartHeartbeatResponse*>(
        &_StartHeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(StartHeartbeatResponse& a, StartHeartbeatResponse& b) { a.Swap(&b); }
  inline void Swap(StartHeartbeatResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartHeartbeatResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartHeartbeatResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<StartHeartbeatResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StartHeartbeatResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StartHeartbeatResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.StartHeartbeatResponse"; }

 protected:
  explicit StartHeartbeatResponse(::google::protobuf::Arena* arena);
  StartHeartbeatResponse(::google::protobuf::Arena* arena, const StartHeartbeatResponse& from);
  StartHeartbeatResponse(::google::protobuf::Arena* arena, StartHeartbeatResponse&& from) noexcept
      : StartHeartbeatResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.StartHeartbeatResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StartHeartbeatResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class StartHeartbeatRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.StartHeartbeatRequest) */ {
 public:
  inline StartHeartbeatRequest() : StartHeartbeatRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StartHeartbeatRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StartHeartbeatRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StartHeartbeatRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline StartHeartbeatRequest(const StartHeartbeatRequest& from) : StartHeartbeatRequest(nullptr, from) {}
  inline StartHeartbeatRequest(StartHeartbeatRequest&& from) noexcept
      : StartHeartbeatRequest(nullptr, std::move(from)) {}
  inline StartHeartbeatRequest& operator=(const StartHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartHeartbeatRequest& operator=(StartHeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartHeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const StartHeartbeatRequest*>(
        &_StartHeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(StartHeartbeatRequest& a, StartHeartbeatRequest& b) { a.Swap(&b); }
  inline void Swap(StartHeartbeatRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartHeartbeatRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartHeartbeatRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<StartHeartbeatRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StartHeartbeatRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StartHeartbeatRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.StartHeartbeatRequest"; }

 protected:
  explicit StartHeartbeatRequest(::google::protobuf::Arena* arena);
  StartHeartbeatRequest(::google::protobuf::Arena* arena, const StartHeartbeatRequest& from);
  StartHeartbeatRequest(::google::protobuf::Arena* arena, StartHeartbeatRequest&& from) noexcept
      : StartHeartbeatRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.StartHeartbeatRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StartHeartbeatRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class SetFailsafeDurationMinimumResponse final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.SetFailsafeDurationMinimumResponse) */ {
 public:
  inline SetFailsafeDurationMinimumResponse() : SetFailsafeDurationMinimumResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetFailsafeDurationMinimumResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetFailsafeDurationMinimumResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetFailsafeDurationMinimumResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetFailsafeDurationMinimumResponse(const SetFailsafeDurationMinimumResponse& from) : SetFailsafeDurationMinimumResponse(nullptr, from) {}
  inline SetFailsafeDurationMinimumResponse(SetFailsafeDurationMinimumResponse&& from) noexcept
      : SetFailsafeDurationMinimumResponse(nullptr, std::move(from)) {}
  inline SetFailsafeDurationMinimumResponse& operator=(const SetFailsafeDurationMinimumResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFailsafeDurationMinimumResponse& operator=(SetFailsafeDurationMinimumResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFailsafeDurationMinimumResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFailsafeDurationMinimumResponse* internal_default_instance() {
    return reinterpret_cast<const SetFailsafeDurationMinimumResponse*>(
        &_SetFailsafeDurationMinimumResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(SetFailsafeDurationMinimumResponse& a, SetFailsafeDurationMinimumResponse& b) { a.Swap(&b); }
  inline void Swap(SetFailsafeDurationMinimumResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFailsafeDurationMinimumResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFailsafeDurationMinimumResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SetFailsafeDurationMinimumResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetFailsafeDurationMinimumResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetFailsafeDurationMinimumResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.SetFailsafeDurationMinimumResponse"; }

 protected:
  explicit SetFailsafeDurationMinimumResponse(::google::protobuf::Arena* arena);
  SetFailsafeDurationMinimumResponse(::google::protobuf::Arena* arena, const SetFailsafeDurationMinimumResponse& from);
  SetFailsafeDurationMinimumResponse(::google::protobuf::Arena* arena, SetFailsafeDurationMinimumResponse&& from) noexcept
      : SetFailsafeDurationMinimumResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.SetFailsafeDurationMinimumResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetFailsafeDurationMinimumResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class SetFailsafeDurationMinimumRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cs_lpc.SetFailsafeDurationMinimumRequest) */ {
 public:
  inline SetFailsafeDurationMinimumRequest() : SetFailsafeDurationMinimumRequest(nullptr) {}
  ~SetFailsafeDurationMinimumRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetFailsafeDurationMinimumRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetFailsafeDurationMinimumRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetFailsafeDurationMinimumRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetFailsafeDurationMinimumRequest(const SetFailsafeDurationMinimumRequest& from) : SetFailsafeDurationMinimumRequest(nullptr, from) {}
  inline SetFailsafeDurationMinimumRequest(SetFailsafeDurationMinimumRequest&& from) noexcept
      : SetFailsafeDurationMinimumRequest(nullptr, std::move(from)) {}
  inline SetFailsafeDurationMinimumRequest& operator=(const SetFailsafeDurationMinimumRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFailsafeDurationMinimumRequest& operator=(SetFailsafeDurationMinimumRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFailsafeDurationMinimumRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFailsafeDurationMinimumRequest* internal_default_instance() {
    return reinterpret_cast<const SetFailsafeDurationMinimumRequest*>(
        &_SetFailsafeDurationMinimumRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(SetFailsafeDurationMinimumRequest& a, SetFailsafeDurationMinimumRequest& b) { a.Swap(&b); }
  inline void Swap(SetFailsafeDurationMinimumRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFailsafeDurationMinimumRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFailsafeDurationMinimumRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetFailsafeDurationMinimumRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetFailsafeDurationMinimumRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetFailsafeDurationMinimumRequest& from) { SetFailsafeDurationMinimumRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetFailsafeDurationMinimumRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.SetFailsafeDurationMinimumRequest"; }

 protected:
  explicit SetFailsafeDurationMinimumRequest(::google::protobuf::Arena* arena);
  SetFailsafeDurationMinimumRequest(::google::protobuf::Arena* arena, const SetFailsafeDurationMinimumRequest& from);
  SetFailsafeDurationMinimumRequest(::google::protobuf::Arena* arena, SetFailsafeDurationMinimumRequest&& from) noexcept
      : SetFailsafeDurationMinimumRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDurationNanosecondsFieldNumber = 1,
    kIsChangeableFieldNumber = 2,
  };
  // int64 duration_nanoseconds = 1;
  void clear_duration_nanoseconds() ;
  ::int64_t duration_nanoseconds() const;
  void set_duration_nanoseconds(::int64_t value);

  private:
  ::int64_t _internal_duration_nanoseconds() const;
  void _internal_set_duration_nanoseconds(::int64_t value);

  public:
  // bool is_changeable = 2;
  void clear_is_changeable() ;
  bool is_changeable() const;
  void set_is_changeable(bool value);

  private:
  bool _internal_is_changeable() const;
  void _internal_set_is_changeable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cs_lpc.SetFailsafeDurationMinimumRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetFailsafeDurationMinimumRequest& from_msg);
    ::int64_t duration_nanoseconds_;
    bool is_changeable_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class SetFailsafeConsumptionActivePowerLimitResponse final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.SetFailsafeConsumptionActivePowerLimitResponse) */ {
 public:
  inline SetFailsafeConsumptionActivePowerLimitResponse() : SetFailsafeConsumptionActivePowerLimitResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetFailsafeConsumptionActivePowerLimitResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetFailsafeConsumptionActivePowerLimitResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetFailsafeConsumptionActivePowerLimitResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetFailsafeConsumptionActivePowerLimitResponse(const SetFailsafeConsumptionActivePowerLimitResponse& from) : SetFailsafeConsumptionActivePowerLimitResponse(nullptr, from) {}
  inline SetFailsafeConsumptionActivePowerLimitResponse(SetFailsafeConsumptionActivePowerLimitResponse&& from) noexcept
      : SetFailsafeConsumptionActivePowerLimitResponse(nullptr, std::move(from)) {}
  inline SetFailsafeConsumptionActivePowerLimitResponse& operator=(const SetFailsafeConsumptionActivePowerLimitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFailsafeConsumptionActivePowerLimitResponse& operator=(SetFailsafeConsumptionActivePowerLimitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFailsafeConsumptionActivePowerLimitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFailsafeConsumptionActivePowerLimitResponse* internal_default_instance() {
    return reinterpret_cast<const SetFailsafeConsumptionActivePowerLimitResponse*>(
        &_SetFailsafeConsumptionActivePowerLimitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(SetFailsafeConsumptionActivePowerLimitResponse& a, SetFailsafeConsumptionActivePowerLimitResponse& b) { a.Swap(&b); }
  inline void Swap(SetFailsafeConsumptionActivePowerLimitResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFailsafeConsumptionActivePowerLimitResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFailsafeConsumptionActivePowerLimitResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SetFailsafeConsumptionActivePowerLimitResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetFailsafeConsumptionActivePowerLimitResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetFailsafeConsumptionActivePowerLimitResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.SetFailsafeConsumptionActivePowerLimitResponse"; }

 protected:
  explicit SetFailsafeConsumptionActivePowerLimitResponse(::google::protobuf::Arena* arena);
  SetFailsafeConsumptionActivePowerLimitResponse(::google::protobuf::Arena* arena, const SetFailsafeConsumptionActivePowerLimitResponse& from);
  SetFailsafeConsumptionActivePowerLimitResponse(::google::protobuf::Arena* arena, SetFailsafeConsumptionActivePowerLimitResponse&& from) noexcept
      : SetFailsafeConsumptionActivePowerLimitResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.SetFailsafeConsumptionActivePowerLimitResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetFailsafeConsumptionActivePowerLimitResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class SetFailsafeConsumptionActivePowerLimitRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cs_lpc.SetFailsafeConsumptionActivePowerLimitRequest) */ {
 public:
  inline SetFailsafeConsumptionActivePowerLimitRequest() : SetFailsafeConsumptionActivePowerLimitRequest(nullptr) {}
  ~SetFailsafeConsumptionActivePowerLimitRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetFailsafeConsumptionActivePowerLimitRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetFailsafeConsumptionActivePowerLimitRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetFailsafeConsumptionActivePowerLimitRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetFailsafeConsumptionActivePowerLimitRequest(const SetFailsafeConsumptionActivePowerLimitRequest& from) : SetFailsafeConsumptionActivePowerLimitRequest(nullptr, from) {}
  inline SetFailsafeConsumptionActivePowerLimitRequest(SetFailsafeConsumptionActivePowerLimitRequest&& from) noexcept
      : SetFailsafeConsumptionActivePowerLimitRequest(nullptr, std::move(from)) {}
  inline SetFailsafeConsumptionActivePowerLimitRequest& operator=(const SetFailsafeConsumptionActivePowerLimitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFailsafeConsumptionActivePowerLimitRequest& operator=(SetFailsafeConsumptionActivePowerLimitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFailsafeConsumptionActivePowerLimitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFailsafeConsumptionActivePowerLimitRequest* internal_default_instance() {
    return reinterpret_cast<const SetFailsafeConsumptionActivePowerLimitRequest*>(
        &_SetFailsafeConsumptionActivePowerLimitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(SetFailsafeConsumptionActivePowerLimitRequest& a, SetFailsafeConsumptionActivePowerLimitRequest& b) { a.Swap(&b); }
  inline void Swap(SetFailsafeConsumptionActivePowerLimitRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFailsafeConsumptionActivePowerLimitRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFailsafeConsumptionActivePowerLimitRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetFailsafeConsumptionActivePowerLimitRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetFailsafeConsumptionActivePowerLimitRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetFailsafeConsumptionActivePowerLimitRequest& from) { SetFailsafeConsumptionActivePowerLimitRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetFailsafeConsumptionActivePowerLimitRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.SetFailsafeConsumptionActivePowerLimitRequest"; }

 protected:
  explicit SetFailsafeConsumptionActivePowerLimitRequest(::google::protobuf::Arena* arena);
  SetFailsafeConsumptionActivePowerLimitRequest(::google::protobuf::Arena* arena, const SetFailsafeConsumptionActivePowerLimitRequest& from);
  SetFailsafeConsumptionActivePowerLimitRequest(::google::protobuf::Arena* arena, SetFailsafeConsumptionActivePowerLimitRequest&& from) noexcept
      : SetFailsafeConsumptionActivePowerLimitRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kIsChangeableFieldNumber = 2,
  };
  // double value = 1;
  void clear_value() ;
  double value() const;
  void set_value(double value);

  private:
  double _internal_value() const;
  void _internal_set_value(double value);

  public:
  // bool is_changeable = 2;
  void clear_is_changeable() ;
  bool is_changeable() const;
  void set_is_changeable(bool value);

  private:
  bool _internal_is_changeable() const;
  void _internal_set_is_changeable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cs_lpc.SetFailsafeConsumptionActivePowerLimitRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetFailsafeConsumptionActivePowerLimitRequest& from_msg);
    double value_;
    bool is_changeable_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class SetConsumptionNominalMaxResponse final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.SetConsumptionNominalMaxResponse) */ {
 public:
  inline SetConsumptionNominalMaxResponse() : SetConsumptionNominalMaxResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetConsumptionNominalMaxResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetConsumptionNominalMaxResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetConsumptionNominalMaxResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetConsumptionNominalMaxResponse(const SetConsumptionNominalMaxResponse& from) : SetConsumptionNominalMaxResponse(nullptr, from) {}
  inline SetConsumptionNominalMaxResponse(SetConsumptionNominalMaxResponse&& from) noexcept
      : SetConsumptionNominalMaxResponse(nullptr, std::move(from)) {}
  inline SetConsumptionNominalMaxResponse& operator=(const SetConsumptionNominalMaxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConsumptionNominalMaxResponse& operator=(SetConsumptionNominalMaxResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConsumptionNominalMaxResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConsumptionNominalMaxResponse* internal_default_instance() {
    return reinterpret_cast<const SetConsumptionNominalMaxResponse*>(
        &_SetConsumptionNominalMaxResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(SetConsumptionNominalMaxResponse& a, SetConsumptionNominalMaxResponse& b) { a.Swap(&b); }
  inline void Swap(SetConsumptionNominalMaxResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConsumptionNominalMaxResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConsumptionNominalMaxResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SetConsumptionNominalMaxResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetConsumptionNominalMaxResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetConsumptionNominalMaxResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.SetConsumptionNominalMaxResponse"; }

 protected:
  explicit SetConsumptionNominalMaxResponse(::google::protobuf::Arena* arena);
  SetConsumptionNominalMaxResponse(::google::protobuf::Arena* arena, const SetConsumptionNominalMaxResponse& from);
  SetConsumptionNominalMaxResponse(::google::protobuf::Arena* arena, SetConsumptionNominalMaxResponse&& from) noexcept
      : SetConsumptionNominalMaxResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.SetConsumptionNominalMaxResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetConsumptionNominalMaxResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class SetConsumptionNominalMaxRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cs_lpc.SetConsumptionNominalMaxRequest) */ {
 public:
  inline SetConsumptionNominalMaxRequest() : SetConsumptionNominalMaxRequest(nullptr) {}
  ~SetConsumptionNominalMaxRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetConsumptionNominalMaxRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetConsumptionNominalMaxRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetConsumptionNominalMaxRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetConsumptionNominalMaxRequest(const SetConsumptionNominalMaxRequest& from) : SetConsumptionNominalMaxRequest(nullptr, from) {}
  inline SetConsumptionNominalMaxRequest(SetConsumptionNominalMaxRequest&& from) noexcept
      : SetConsumptionNominalMaxRequest(nullptr, std::move(from)) {}
  inline SetConsumptionNominalMaxRequest& operator=(const SetConsumptionNominalMaxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConsumptionNominalMaxRequest& operator=(SetConsumptionNominalMaxRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConsumptionNominalMaxRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConsumptionNominalMaxRequest* internal_default_instance() {
    return reinterpret_cast<const SetConsumptionNominalMaxRequest*>(
        &_SetConsumptionNominalMaxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(SetConsumptionNominalMaxRequest& a, SetConsumptionNominalMaxRequest& b) { a.Swap(&b); }
  inline void Swap(SetConsumptionNominalMaxRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConsumptionNominalMaxRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConsumptionNominalMaxRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetConsumptionNominalMaxRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetConsumptionNominalMaxRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetConsumptionNominalMaxRequest& from) { SetConsumptionNominalMaxRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetConsumptionNominalMaxRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.SetConsumptionNominalMaxRequest"; }

 protected:
  explicit SetConsumptionNominalMaxRequest(::google::protobuf::Arena* arena);
  SetConsumptionNominalMaxRequest(::google::protobuf::Arena* arena, const SetConsumptionNominalMaxRequest& from);
  SetConsumptionNominalMaxRequest(::google::protobuf::Arena* arena, SetConsumptionNominalMaxRequest&& from) noexcept
      : SetConsumptionNominalMaxRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // double value = 1;
  void clear_value() ;
  double value() const;
  void set_value(double value);

  private:
  double _internal_value() const;
  void _internal_set_value(double value);

  public:
  // @@protoc_insertion_point(class_scope:cs_lpc.SetConsumptionNominalMaxRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetConsumptionNominalMaxRequest& from_msg);
    double value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class SetConsumptionLimitResponse final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.SetConsumptionLimitResponse) */ {
 public:
  inline SetConsumptionLimitResponse() : SetConsumptionLimitResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetConsumptionLimitResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetConsumptionLimitResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetConsumptionLimitResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetConsumptionLimitResponse(const SetConsumptionLimitResponse& from) : SetConsumptionLimitResponse(nullptr, from) {}
  inline SetConsumptionLimitResponse(SetConsumptionLimitResponse&& from) noexcept
      : SetConsumptionLimitResponse(nullptr, std::move(from)) {}
  inline SetConsumptionLimitResponse& operator=(const SetConsumptionLimitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConsumptionLimitResponse& operator=(SetConsumptionLimitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConsumptionLimitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConsumptionLimitResponse* internal_default_instance() {
    return reinterpret_cast<const SetConsumptionLimitResponse*>(
        &_SetConsumptionLimitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(SetConsumptionLimitResponse& a, SetConsumptionLimitResponse& b) { a.Swap(&b); }
  inline void Swap(SetConsumptionLimitResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConsumptionLimitResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConsumptionLimitResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SetConsumptionLimitResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetConsumptionLimitResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetConsumptionLimitResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.SetConsumptionLimitResponse"; }

 protected:
  explicit SetConsumptionLimitResponse(::google::protobuf::Arena* arena);
  SetConsumptionLimitResponse(::google::protobuf::Arena* arena, const SetConsumptionLimitResponse& from);
  SetConsumptionLimitResponse(::google::protobuf::Arena* arena, SetConsumptionLimitResponse&& from) noexcept
      : SetConsumptionLimitResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.SetConsumptionLimitResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetConsumptionLimitResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class PendingConsumptionLimitRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.PendingConsumptionLimitRequest) */ {
 public:
  inline PendingConsumptionLimitRequest() : PendingConsumptionLimitRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PendingConsumptionLimitRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PendingConsumptionLimitRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PendingConsumptionLimitRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PendingConsumptionLimitRequest(const PendingConsumptionLimitRequest& from) : PendingConsumptionLimitRequest(nullptr, from) {}
  inline PendingConsumptionLimitRequest(PendingConsumptionLimitRequest&& from) noexcept
      : PendingConsumptionLimitRequest(nullptr, std::move(from)) {}
  inline PendingConsumptionLimitRequest& operator=(const PendingConsumptionLimitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PendingConsumptionLimitRequest& operator=(PendingConsumptionLimitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PendingConsumptionLimitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PendingConsumptionLimitRequest* internal_default_instance() {
    return reinterpret_cast<const PendingConsumptionLimitRequest*>(
        &_PendingConsumptionLimitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(PendingConsumptionLimitRequest& a, PendingConsumptionLimitRequest& b) { a.Swap(&b); }
  inline void Swap(PendingConsumptionLimitRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PendingConsumptionLimitRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PendingConsumptionLimitRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<PendingConsumptionLimitRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PendingConsumptionLimitRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PendingConsumptionLimitRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.PendingConsumptionLimitRequest"; }

 protected:
  explicit PendingConsumptionLimitRequest(::google::protobuf::Arena* arena);
  PendingConsumptionLimitRequest(::google::protobuf::Arena* arena, const PendingConsumptionLimitRequest& from);
  PendingConsumptionLimitRequest(::google::protobuf::Arena* arena, PendingConsumptionLimitRequest&& from) noexcept
      : PendingConsumptionLimitRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.PendingConsumptionLimitRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PendingConsumptionLimitRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class IsHeartbeatWithinDurationResponse final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cs_lpc.IsHeartbeatWithinDurationResponse) */ {
 public:
  inline IsHeartbeatWithinDurationResponse() : IsHeartbeatWithinDurationResponse(nullptr) {}
  ~IsHeartbeatWithinDurationResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IsHeartbeatWithinDurationResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IsHeartbeatWithinDurationResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IsHeartbeatWithinDurationResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline IsHeartbeatWithinDurationResponse(const IsHeartbeatWithinDurationResponse& from) : IsHeartbeatWithinDurationResponse(nullptr, from) {}
  inline IsHeartbeatWithinDurationResponse(IsHeartbeatWithinDurationResponse&& from) noexcept
      : IsHeartbeatWithinDurationResponse(nullptr, std::move(from)) {}
  inline IsHeartbeatWithinDurationResponse& operator=(const IsHeartbeatWithinDurationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsHeartbeatWithinDurationResponse& operator=(IsHeartbeatWithinDurationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsHeartbeatWithinDurationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsHeartbeatWithinDurationResponse* internal_default_instance() {
    return reinterpret_cast<const IsHeartbeatWithinDurationResponse*>(
        &_IsHeartbeatWithinDurationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(IsHeartbeatWithinDurationResponse& a, IsHeartbeatWithinDurationResponse& b) { a.Swap(&b); }
  inline void Swap(IsHeartbeatWithinDurationResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsHeartbeatWithinDurationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsHeartbeatWithinDurationResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<IsHeartbeatWithinDurationResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IsHeartbeatWithinDurationResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const IsHeartbeatWithinDurationResponse& from) { IsHeartbeatWithinDurationResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IsHeartbeatWithinDurationResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.IsHeartbeatWithinDurationResponse"; }

 protected:
  explicit IsHeartbeatWithinDurationResponse(::google::protobuf::Arena* arena);
  IsHeartbeatWithinDurationResponse(::google::protobuf::Arena* arena, const IsHeartbeatWithinDurationResponse& from);
  IsHeartbeatWithinDurationResponse(::google::protobuf::Arena* arena, IsHeartbeatWithinDurationResponse&& from) noexcept
      : IsHeartbeatWithinDurationResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIsWithinDurationFieldNumber = 1,
  };
  // bool is_within_duration = 1;
  void clear_is_within_duration() ;
  bool is_within_duration() const;
  void set_is_within_duration(bool value);

  private:
  bool _internal_is_within_duration() const;
  void _internal_set_is_within_duration(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cs_lpc.IsHeartbeatWithinDurationResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IsHeartbeatWithinDurationResponse& from_msg);
    bool is_within_duration_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class IsHeartbeatWithinDurationRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.IsHeartbeatWithinDurationRequest) */ {
 public:
  inline IsHeartbeatWithinDurationRequest() : IsHeartbeatWithinDurationRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IsHeartbeatWithinDurationRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IsHeartbeatWithinDurationRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IsHeartbeatWithinDurationRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline IsHeartbeatWithinDurationRequest(const IsHeartbeatWithinDurationRequest& from) : IsHeartbeatWithinDurationRequest(nullptr, from) {}
  inline IsHeartbeatWithinDurationRequest(IsHeartbeatWithinDurationRequest&& from) noexcept
      : IsHeartbeatWithinDurationRequest(nullptr, std::move(from)) {}
  inline IsHeartbeatWithinDurationRequest& operator=(const IsHeartbeatWithinDurationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsHeartbeatWithinDurationRequest& operator=(IsHeartbeatWithinDurationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsHeartbeatWithinDurationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsHeartbeatWithinDurationRequest* internal_default_instance() {
    return reinterpret_cast<const IsHeartbeatWithinDurationRequest*>(
        &_IsHeartbeatWithinDurationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(IsHeartbeatWithinDurationRequest& a, IsHeartbeatWithinDurationRequest& b) { a.Swap(&b); }
  inline void Swap(IsHeartbeatWithinDurationRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsHeartbeatWithinDurationRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsHeartbeatWithinDurationRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<IsHeartbeatWithinDurationRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const IsHeartbeatWithinDurationRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const IsHeartbeatWithinDurationRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.IsHeartbeatWithinDurationRequest"; }

 protected:
  explicit IsHeartbeatWithinDurationRequest(::google::protobuf::Arena* arena);
  IsHeartbeatWithinDurationRequest(::google::protobuf::Arena* arena, const IsHeartbeatWithinDurationRequest& from);
  IsHeartbeatWithinDurationRequest(::google::protobuf::Arena* arena, IsHeartbeatWithinDurationRequest&& from) noexcept
      : IsHeartbeatWithinDurationRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.IsHeartbeatWithinDurationRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IsHeartbeatWithinDurationRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class FailsafeDurationMinimumResponse final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cs_lpc.FailsafeDurationMinimumResponse) */ {
 public:
  inline FailsafeDurationMinimumResponse() : FailsafeDurationMinimumResponse(nullptr) {}
  ~FailsafeDurationMinimumResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FailsafeDurationMinimumResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FailsafeDurationMinimumResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FailsafeDurationMinimumResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline FailsafeDurationMinimumResponse(const FailsafeDurationMinimumResponse& from) : FailsafeDurationMinimumResponse(nullptr, from) {}
  inline FailsafeDurationMinimumResponse(FailsafeDurationMinimumResponse&& from) noexcept
      : FailsafeDurationMinimumResponse(nullptr, std::move(from)) {}
  inline FailsafeDurationMinimumResponse& operator=(const FailsafeDurationMinimumResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailsafeDurationMinimumResponse& operator=(FailsafeDurationMinimumResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailsafeDurationMinimumResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FailsafeDurationMinimumResponse* internal_default_instance() {
    return reinterpret_cast<const FailsafeDurationMinimumResponse*>(
        &_FailsafeDurationMinimumResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(FailsafeDurationMinimumResponse& a, FailsafeDurationMinimumResponse& b) { a.Swap(&b); }
  inline void Swap(FailsafeDurationMinimumResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailsafeDurationMinimumResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailsafeDurationMinimumResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FailsafeDurationMinimumResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FailsafeDurationMinimumResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FailsafeDurationMinimumResponse& from) { FailsafeDurationMinimumResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FailsafeDurationMinimumResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.FailsafeDurationMinimumResponse"; }

 protected:
  explicit FailsafeDurationMinimumResponse(::google::protobuf::Arena* arena);
  FailsafeDurationMinimumResponse(::google::protobuf::Arena* arena, const FailsafeDurationMinimumResponse& from);
  FailsafeDurationMinimumResponse(::google::protobuf::Arena* arena, FailsafeDurationMinimumResponse&& from) noexcept
      : FailsafeDurationMinimumResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDurationNanosecondsFieldNumber = 1,
    kIsChangeableFieldNumber = 2,
  };
  // int64 duration_nanoseconds = 1;
  void clear_duration_nanoseconds() ;
  ::int64_t duration_nanoseconds() const;
  void set_duration_nanoseconds(::int64_t value);

  private:
  ::int64_t _internal_duration_nanoseconds() const;
  void _internal_set_duration_nanoseconds(::int64_t value);

  public:
  // bool is_changeable = 2;
  void clear_is_changeable() ;
  bool is_changeable() const;
  void set_is_changeable(bool value);

  private:
  bool _internal_is_changeable() const;
  void _internal_set_is_changeable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cs_lpc.FailsafeDurationMinimumResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FailsafeDurationMinimumResponse& from_msg);
    ::int64_t duration_nanoseconds_;
    bool is_changeable_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class FailsafeDurationMinimumRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.FailsafeDurationMinimumRequest) */ {
 public:
  inline FailsafeDurationMinimumRequest() : FailsafeDurationMinimumRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FailsafeDurationMinimumRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FailsafeDurationMinimumRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FailsafeDurationMinimumRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline FailsafeDurationMinimumRequest(const FailsafeDurationMinimumRequest& from) : FailsafeDurationMinimumRequest(nullptr, from) {}
  inline FailsafeDurationMinimumRequest(FailsafeDurationMinimumRequest&& from) noexcept
      : FailsafeDurationMinimumRequest(nullptr, std::move(from)) {}
  inline FailsafeDurationMinimumRequest& operator=(const FailsafeDurationMinimumRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailsafeDurationMinimumRequest& operator=(FailsafeDurationMinimumRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailsafeDurationMinimumRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FailsafeDurationMinimumRequest* internal_default_instance() {
    return reinterpret_cast<const FailsafeDurationMinimumRequest*>(
        &_FailsafeDurationMinimumRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(FailsafeDurationMinimumRequest& a, FailsafeDurationMinimumRequest& b) { a.Swap(&b); }
  inline void Swap(FailsafeDurationMinimumRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailsafeDurationMinimumRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailsafeDurationMinimumRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<FailsafeDurationMinimumRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FailsafeDurationMinimumRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FailsafeDurationMinimumRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.FailsafeDurationMinimumRequest"; }

 protected:
  explicit FailsafeDurationMinimumRequest(::google::protobuf::Arena* arena);
  FailsafeDurationMinimumRequest(::google::protobuf::Arena* arena, const FailsafeDurationMinimumRequest& from);
  FailsafeDurationMinimumRequest(::google::protobuf::Arena* arena, FailsafeDurationMinimumRequest&& from) noexcept
      : FailsafeDurationMinimumRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.FailsafeDurationMinimumRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FailsafeDurationMinimumRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class FailsafeConsumptionActivePowerLimitResponse final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cs_lpc.FailsafeConsumptionActivePowerLimitResponse) */ {
 public:
  inline FailsafeConsumptionActivePowerLimitResponse() : FailsafeConsumptionActivePowerLimitResponse(nullptr) {}
  ~FailsafeConsumptionActivePowerLimitResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FailsafeConsumptionActivePowerLimitResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FailsafeConsumptionActivePowerLimitResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FailsafeConsumptionActivePowerLimitResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline FailsafeConsumptionActivePowerLimitResponse(const FailsafeConsumptionActivePowerLimitResponse& from) : FailsafeConsumptionActivePowerLimitResponse(nullptr, from) {}
  inline FailsafeConsumptionActivePowerLimitResponse(FailsafeConsumptionActivePowerLimitResponse&& from) noexcept
      : FailsafeConsumptionActivePowerLimitResponse(nullptr, std::move(from)) {}
  inline FailsafeConsumptionActivePowerLimitResponse& operator=(const FailsafeConsumptionActivePowerLimitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailsafeConsumptionActivePowerLimitResponse& operator=(FailsafeConsumptionActivePowerLimitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailsafeConsumptionActivePowerLimitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FailsafeConsumptionActivePowerLimitResponse* internal_default_instance() {
    return reinterpret_cast<const FailsafeConsumptionActivePowerLimitResponse*>(
        &_FailsafeConsumptionActivePowerLimitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(FailsafeConsumptionActivePowerLimitResponse& a, FailsafeConsumptionActivePowerLimitResponse& b) { a.Swap(&b); }
  inline void Swap(FailsafeConsumptionActivePowerLimitResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailsafeConsumptionActivePowerLimitResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailsafeConsumptionActivePowerLimitResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FailsafeConsumptionActivePowerLimitResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FailsafeConsumptionActivePowerLimitResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FailsafeConsumptionActivePowerLimitResponse& from) { FailsafeConsumptionActivePowerLimitResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FailsafeConsumptionActivePowerLimitResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.FailsafeConsumptionActivePowerLimitResponse"; }

 protected:
  explicit FailsafeConsumptionActivePowerLimitResponse(::google::protobuf::Arena* arena);
  FailsafeConsumptionActivePowerLimitResponse(::google::protobuf::Arena* arena, const FailsafeConsumptionActivePowerLimitResponse& from);
  FailsafeConsumptionActivePowerLimitResponse(::google::protobuf::Arena* arena, FailsafeConsumptionActivePowerLimitResponse&& from) noexcept
      : FailsafeConsumptionActivePowerLimitResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLimitFieldNumber = 1,
    kIsChangeableFieldNumber = 2,
  };
  // double limit = 1;
  void clear_limit() ;
  double limit() const;
  void set_limit(double value);

  private:
  double _internal_limit() const;
  void _internal_set_limit(double value);

  public:
  // bool is_changeable = 2;
  void clear_is_changeable() ;
  bool is_changeable() const;
  void set_is_changeable(bool value);

  private:
  bool _internal_is_changeable() const;
  void _internal_set_is_changeable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cs_lpc.FailsafeConsumptionActivePowerLimitResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FailsafeConsumptionActivePowerLimitResponse& from_msg);
    double limit_;
    bool is_changeable_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class FailsafeConsumptionActivePowerLimitRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.FailsafeConsumptionActivePowerLimitRequest) */ {
 public:
  inline FailsafeConsumptionActivePowerLimitRequest() : FailsafeConsumptionActivePowerLimitRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FailsafeConsumptionActivePowerLimitRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FailsafeConsumptionActivePowerLimitRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FailsafeConsumptionActivePowerLimitRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline FailsafeConsumptionActivePowerLimitRequest(const FailsafeConsumptionActivePowerLimitRequest& from) : FailsafeConsumptionActivePowerLimitRequest(nullptr, from) {}
  inline FailsafeConsumptionActivePowerLimitRequest(FailsafeConsumptionActivePowerLimitRequest&& from) noexcept
      : FailsafeConsumptionActivePowerLimitRequest(nullptr, std::move(from)) {}
  inline FailsafeConsumptionActivePowerLimitRequest& operator=(const FailsafeConsumptionActivePowerLimitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailsafeConsumptionActivePowerLimitRequest& operator=(FailsafeConsumptionActivePowerLimitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailsafeConsumptionActivePowerLimitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FailsafeConsumptionActivePowerLimitRequest* internal_default_instance() {
    return reinterpret_cast<const FailsafeConsumptionActivePowerLimitRequest*>(
        &_FailsafeConsumptionActivePowerLimitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(FailsafeConsumptionActivePowerLimitRequest& a, FailsafeConsumptionActivePowerLimitRequest& b) { a.Swap(&b); }
  inline void Swap(FailsafeConsumptionActivePowerLimitRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailsafeConsumptionActivePowerLimitRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailsafeConsumptionActivePowerLimitRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<FailsafeConsumptionActivePowerLimitRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FailsafeConsumptionActivePowerLimitRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FailsafeConsumptionActivePowerLimitRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.FailsafeConsumptionActivePowerLimitRequest"; }

 protected:
  explicit FailsafeConsumptionActivePowerLimitRequest(::google::protobuf::Arena* arena);
  FailsafeConsumptionActivePowerLimitRequest(::google::protobuf::Arena* arena, const FailsafeConsumptionActivePowerLimitRequest& from);
  FailsafeConsumptionActivePowerLimitRequest(::google::protobuf::Arena* arena, FailsafeConsumptionActivePowerLimitRequest&& from) noexcept
      : FailsafeConsumptionActivePowerLimitRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.FailsafeConsumptionActivePowerLimitRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FailsafeConsumptionActivePowerLimitRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class ConsumptionNominalMaxResponse final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cs_lpc.ConsumptionNominalMaxResponse) */ {
 public:
  inline ConsumptionNominalMaxResponse() : ConsumptionNominalMaxResponse(nullptr) {}
  ~ConsumptionNominalMaxResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConsumptionNominalMaxResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConsumptionNominalMaxResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConsumptionNominalMaxResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConsumptionNominalMaxResponse(const ConsumptionNominalMaxResponse& from) : ConsumptionNominalMaxResponse(nullptr, from) {}
  inline ConsumptionNominalMaxResponse(ConsumptionNominalMaxResponse&& from) noexcept
      : ConsumptionNominalMaxResponse(nullptr, std::move(from)) {}
  inline ConsumptionNominalMaxResponse& operator=(const ConsumptionNominalMaxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsumptionNominalMaxResponse& operator=(ConsumptionNominalMaxResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsumptionNominalMaxResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsumptionNominalMaxResponse* internal_default_instance() {
    return reinterpret_cast<const ConsumptionNominalMaxResponse*>(
        &_ConsumptionNominalMaxResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(ConsumptionNominalMaxResponse& a, ConsumptionNominalMaxResponse& b) { a.Swap(&b); }
  inline void Swap(ConsumptionNominalMaxResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsumptionNominalMaxResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsumptionNominalMaxResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConsumptionNominalMaxResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConsumptionNominalMaxResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConsumptionNominalMaxResponse& from) { ConsumptionNominalMaxResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConsumptionNominalMaxResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.ConsumptionNominalMaxResponse"; }

 protected:
  explicit ConsumptionNominalMaxResponse(::google::protobuf::Arena* arena);
  ConsumptionNominalMaxResponse(::google::protobuf::Arena* arena, const ConsumptionNominalMaxResponse& from);
  ConsumptionNominalMaxResponse(::google::protobuf::Arena* arena, ConsumptionNominalMaxResponse&& from) noexcept
      : ConsumptionNominalMaxResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // double value = 1;
  void clear_value() ;
  double value() const;
  void set_value(double value);

  private:
  double _internal_value() const;
  void _internal_set_value(double value);

  public:
  // @@protoc_insertion_point(class_scope:cs_lpc.ConsumptionNominalMaxResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConsumptionNominalMaxResponse& from_msg);
    double value_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class ConsumptionNominalMaxRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.ConsumptionNominalMaxRequest) */ {
 public:
  inline ConsumptionNominalMaxRequest() : ConsumptionNominalMaxRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConsumptionNominalMaxRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConsumptionNominalMaxRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConsumptionNominalMaxRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConsumptionNominalMaxRequest(const ConsumptionNominalMaxRequest& from) : ConsumptionNominalMaxRequest(nullptr, from) {}
  inline ConsumptionNominalMaxRequest(ConsumptionNominalMaxRequest&& from) noexcept
      : ConsumptionNominalMaxRequest(nullptr, std::move(from)) {}
  inline ConsumptionNominalMaxRequest& operator=(const ConsumptionNominalMaxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsumptionNominalMaxRequest& operator=(ConsumptionNominalMaxRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsumptionNominalMaxRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsumptionNominalMaxRequest* internal_default_instance() {
    return reinterpret_cast<const ConsumptionNominalMaxRequest*>(
        &_ConsumptionNominalMaxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(ConsumptionNominalMaxRequest& a, ConsumptionNominalMaxRequest& b) { a.Swap(&b); }
  inline void Swap(ConsumptionNominalMaxRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsumptionNominalMaxRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsumptionNominalMaxRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ConsumptionNominalMaxRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ConsumptionNominalMaxRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ConsumptionNominalMaxRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.ConsumptionNominalMaxRequest"; }

 protected:
  explicit ConsumptionNominalMaxRequest(::google::protobuf::Arena* arena);
  ConsumptionNominalMaxRequest(::google::protobuf::Arena* arena, const ConsumptionNominalMaxRequest& from);
  ConsumptionNominalMaxRequest(::google::protobuf::Arena* arena, ConsumptionNominalMaxRequest&& from) noexcept
      : ConsumptionNominalMaxRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.ConsumptionNominalMaxRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConsumptionNominalMaxRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class ConsumptionLimitRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.ConsumptionLimitRequest) */ {
 public:
  inline ConsumptionLimitRequest() : ConsumptionLimitRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConsumptionLimitRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConsumptionLimitRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConsumptionLimitRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConsumptionLimitRequest(const ConsumptionLimitRequest& from) : ConsumptionLimitRequest(nullptr, from) {}
  inline ConsumptionLimitRequest(ConsumptionLimitRequest&& from) noexcept
      : ConsumptionLimitRequest(nullptr, std::move(from)) {}
  inline ConsumptionLimitRequest& operator=(const ConsumptionLimitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsumptionLimitRequest& operator=(ConsumptionLimitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsumptionLimitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsumptionLimitRequest* internal_default_instance() {
    return reinterpret_cast<const ConsumptionLimitRequest*>(
        &_ConsumptionLimitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(ConsumptionLimitRequest& a, ConsumptionLimitRequest& b) { a.Swap(&b); }
  inline void Swap(ConsumptionLimitRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsumptionLimitRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsumptionLimitRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ConsumptionLimitRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ConsumptionLimitRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ConsumptionLimitRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.ConsumptionLimitRequest"; }

 protected:
  explicit ConsumptionLimitRequest(::google::protobuf::Arena* arena);
  ConsumptionLimitRequest(::google::protobuf::Arena* arena, const ConsumptionLimitRequest& from);
  ConsumptionLimitRequest(::google::protobuf::Arena* arena, ConsumptionLimitRequest&& from) noexcept
      : ConsumptionLimitRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.ConsumptionLimitRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConsumptionLimitRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class ApproveOrDenyConsumptionLimitResponse final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:cs_lpc.ApproveOrDenyConsumptionLimitResponse) */ {
 public:
  inline ApproveOrDenyConsumptionLimitResponse() : ApproveOrDenyConsumptionLimitResponse(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ApproveOrDenyConsumptionLimitResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ApproveOrDenyConsumptionLimitResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApproveOrDenyConsumptionLimitResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ApproveOrDenyConsumptionLimitResponse(const ApproveOrDenyConsumptionLimitResponse& from) : ApproveOrDenyConsumptionLimitResponse(nullptr, from) {}
  inline ApproveOrDenyConsumptionLimitResponse(ApproveOrDenyConsumptionLimitResponse&& from) noexcept
      : ApproveOrDenyConsumptionLimitResponse(nullptr, std::move(from)) {}
  inline ApproveOrDenyConsumptionLimitResponse& operator=(const ApproveOrDenyConsumptionLimitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApproveOrDenyConsumptionLimitResponse& operator=(ApproveOrDenyConsumptionLimitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApproveOrDenyConsumptionLimitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApproveOrDenyConsumptionLimitResponse* internal_default_instance() {
    return reinterpret_cast<const ApproveOrDenyConsumptionLimitResponse*>(
        &_ApproveOrDenyConsumptionLimitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(ApproveOrDenyConsumptionLimitResponse& a, ApproveOrDenyConsumptionLimitResponse& b) { a.Swap(&b); }
  inline void Swap(ApproveOrDenyConsumptionLimitResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApproveOrDenyConsumptionLimitResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApproveOrDenyConsumptionLimitResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<ApproveOrDenyConsumptionLimitResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ApproveOrDenyConsumptionLimitResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ApproveOrDenyConsumptionLimitResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.ApproveOrDenyConsumptionLimitResponse"; }

 protected:
  explicit ApproveOrDenyConsumptionLimitResponse(::google::protobuf::Arena* arena);
  ApproveOrDenyConsumptionLimitResponse(::google::protobuf::Arena* arena, const ApproveOrDenyConsumptionLimitResponse& from);
  ApproveOrDenyConsumptionLimitResponse(::google::protobuf::Arena* arena, ApproveOrDenyConsumptionLimitResponse&& from) noexcept
      : ApproveOrDenyConsumptionLimitResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:cs_lpc.ApproveOrDenyConsumptionLimitResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ApproveOrDenyConsumptionLimitResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class ApproveOrDenyConsumptionLimitRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cs_lpc.ApproveOrDenyConsumptionLimitRequest) */ {
 public:
  inline ApproveOrDenyConsumptionLimitRequest() : ApproveOrDenyConsumptionLimitRequest(nullptr) {}
  ~ApproveOrDenyConsumptionLimitRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ApproveOrDenyConsumptionLimitRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ApproveOrDenyConsumptionLimitRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApproveOrDenyConsumptionLimitRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ApproveOrDenyConsumptionLimitRequest(const ApproveOrDenyConsumptionLimitRequest& from) : ApproveOrDenyConsumptionLimitRequest(nullptr, from) {}
  inline ApproveOrDenyConsumptionLimitRequest(ApproveOrDenyConsumptionLimitRequest&& from) noexcept
      : ApproveOrDenyConsumptionLimitRequest(nullptr, std::move(from)) {}
  inline ApproveOrDenyConsumptionLimitRequest& operator=(const ApproveOrDenyConsumptionLimitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApproveOrDenyConsumptionLimitRequest& operator=(ApproveOrDenyConsumptionLimitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApproveOrDenyConsumptionLimitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApproveOrDenyConsumptionLimitRequest* internal_default_instance() {
    return reinterpret_cast<const ApproveOrDenyConsumptionLimitRequest*>(
        &_ApproveOrDenyConsumptionLimitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ApproveOrDenyConsumptionLimitRequest& a, ApproveOrDenyConsumptionLimitRequest& b) { a.Swap(&b); }
  inline void Swap(ApproveOrDenyConsumptionLimitRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApproveOrDenyConsumptionLimitRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApproveOrDenyConsumptionLimitRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ApproveOrDenyConsumptionLimitRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ApproveOrDenyConsumptionLimitRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ApproveOrDenyConsumptionLimitRequest& from) { ApproveOrDenyConsumptionLimitRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ApproveOrDenyConsumptionLimitRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.ApproveOrDenyConsumptionLimitRequest"; }

 protected:
  explicit ApproveOrDenyConsumptionLimitRequest(::google::protobuf::Arena* arena);
  ApproveOrDenyConsumptionLimitRequest(::google::protobuf::Arena* arena, const ApproveOrDenyConsumptionLimitRequest& from);
  ApproveOrDenyConsumptionLimitRequest(::google::protobuf::Arena* arena, ApproveOrDenyConsumptionLimitRequest&& from) noexcept
      : ApproveOrDenyConsumptionLimitRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReasonFieldNumber = 3,
    kMsgCounterFieldNumber = 1,
    kApproveFieldNumber = 2,
  };
  // string reason = 3;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // uint64 msg_counter = 1;
  void clear_msg_counter() ;
  ::uint64_t msg_counter() const;
  void set_msg_counter(::uint64_t value);

  private:
  ::uint64_t _internal_msg_counter() const;
  void _internal_set_msg_counter(::uint64_t value);

  public:
  // bool approve = 2;
  void clear_approve() ;
  bool approve() const;
  void set_approve(bool value);

  private:
  bool _internal_approve() const;
  void _internal_set_approve(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cs_lpc.ApproveOrDenyConsumptionLimitRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      58, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ApproveOrDenyConsumptionLimitRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr reason_;
    ::uint64_t msg_counter_;
    bool approve_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class SetConsumptionLimitRequest final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cs_lpc.SetConsumptionLimitRequest) */ {
 public:
  inline SetConsumptionLimitRequest() : SetConsumptionLimitRequest(nullptr) {}
  ~SetConsumptionLimitRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetConsumptionLimitRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetConsumptionLimitRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetConsumptionLimitRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetConsumptionLimitRequest(const SetConsumptionLimitRequest& from) : SetConsumptionLimitRequest(nullptr, from) {}
  inline SetConsumptionLimitRequest(SetConsumptionLimitRequest&& from) noexcept
      : SetConsumptionLimitRequest(nullptr, std::move(from)) {}
  inline SetConsumptionLimitRequest& operator=(const SetConsumptionLimitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetConsumptionLimitRequest& operator=(SetConsumptionLimitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetConsumptionLimitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetConsumptionLimitRequest* internal_default_instance() {
    return reinterpret_cast<const SetConsumptionLimitRequest*>(
        &_SetConsumptionLimitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(SetConsumptionLimitRequest& a, SetConsumptionLimitRequest& b) { a.Swap(&b); }
  inline void Swap(SetConsumptionLimitRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetConsumptionLimitRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetConsumptionLimitRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SetConsumptionLimitRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetConsumptionLimitRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SetConsumptionLimitRequest& from) { SetConsumptionLimitRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetConsumptionLimitRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.SetConsumptionLimitRequest"; }

 protected:
  explicit SetConsumptionLimitRequest(::google::protobuf::Arena* arena);
  SetConsumptionLimitRequest(::google::protobuf::Arena* arena, const SetConsumptionLimitRequest& from);
  SetConsumptionLimitRequest(::google::protobuf::Arena* arena, SetConsumptionLimitRequest&& from) noexcept
      : SetConsumptionLimitRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLoadLimitFieldNumber = 1,
  };
  // .common_types.LoadLimit load_limit = 1;
  bool has_load_limit() const;
  void clear_load_limit() ;
  const ::common_types::LoadLimit& load_limit() const;
  PROTOBUF_NODISCARD ::common_types::LoadLimit* release_load_limit();
  ::common_types::LoadLimit* mutable_load_limit();
  void set_allocated_load_limit(::common_types::LoadLimit* value);
  void unsafe_arena_set_allocated_load_limit(::common_types::LoadLimit* value);
  ::common_types::LoadLimit* unsafe_arena_release_load_limit();

  private:
  const ::common_types::LoadLimit& _internal_load_limit() const;
  ::common_types::LoadLimit* _internal_mutable_load_limit();

  public:
  // @@protoc_insertion_point(class_scope:cs_lpc.SetConsumptionLimitRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetConsumptionLimitRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::common_types::LoadLimit* load_limit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class PendingConsumptionLimitResponse_LoadLimitsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ::uint64_t, ::google::protobuf::Message,
          ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
          ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ::uint64_t, ::google::protobuf::Message,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>;
  PendingConsumptionLimitResponse_LoadLimitsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PendingConsumptionLimitResponse_LoadLimitsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit PendingConsumptionLimitResponse_LoadLimitsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const PendingConsumptionLimitResponse_LoadLimitsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const PendingConsumptionLimitResponse_LoadLimitsEntry_DoNotUse*>(
        &_PendingConsumptionLimitResponse_LoadLimitsEntry_DoNotUse_default_instance_);
  }


 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;
};
// -------------------------------------------------------------------

class ConsumptionLimitResponse final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cs_lpc.ConsumptionLimitResponse) */ {
 public:
  inline ConsumptionLimitResponse() : ConsumptionLimitResponse(nullptr) {}
  ~ConsumptionLimitResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConsumptionLimitResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConsumptionLimitResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConsumptionLimitResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConsumptionLimitResponse(const ConsumptionLimitResponse& from) : ConsumptionLimitResponse(nullptr, from) {}
  inline ConsumptionLimitResponse(ConsumptionLimitResponse&& from) noexcept
      : ConsumptionLimitResponse(nullptr, std::move(from)) {}
  inline ConsumptionLimitResponse& operator=(const ConsumptionLimitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsumptionLimitResponse& operator=(ConsumptionLimitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsumptionLimitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsumptionLimitResponse* internal_default_instance() {
    return reinterpret_cast<const ConsumptionLimitResponse*>(
        &_ConsumptionLimitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ConsumptionLimitResponse& a, ConsumptionLimitResponse& b) { a.Swap(&b); }
  inline void Swap(ConsumptionLimitResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsumptionLimitResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsumptionLimitResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConsumptionLimitResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConsumptionLimitResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConsumptionLimitResponse& from) { ConsumptionLimitResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConsumptionLimitResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.ConsumptionLimitResponse"; }

 protected:
  explicit ConsumptionLimitResponse(::google::protobuf::Arena* arena);
  ConsumptionLimitResponse(::google::protobuf::Arena* arena, const ConsumptionLimitResponse& from);
  ConsumptionLimitResponse(::google::protobuf::Arena* arena, ConsumptionLimitResponse&& from) noexcept
      : ConsumptionLimitResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLoadLimitFieldNumber = 1,
  };
  // .common_types.LoadLimit load_limit = 1;
  bool has_load_limit() const;
  void clear_load_limit() ;
  const ::common_types::LoadLimit& load_limit() const;
  PROTOBUF_NODISCARD ::common_types::LoadLimit* release_load_limit();
  ::common_types::LoadLimit* mutable_load_limit();
  void set_allocated_load_limit(::common_types::LoadLimit* value);
  void unsafe_arena_set_allocated_load_limit(::common_types::LoadLimit* value);
  ::common_types::LoadLimit* unsafe_arena_release_load_limit();

  private:
  const ::common_types::LoadLimit& _internal_load_limit() const;
  ::common_types::LoadLimit* _internal_mutable_load_limit();

  public:
  // @@protoc_insertion_point(class_scope:cs_lpc.ConsumptionLimitResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConsumptionLimitResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::common_types::LoadLimit* load_limit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};
// -------------------------------------------------------------------

class PendingConsumptionLimitResponse final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:cs_lpc.PendingConsumptionLimitResponse) */ {
 public:
  inline PendingConsumptionLimitResponse() : PendingConsumptionLimitResponse(nullptr) {}
  ~PendingConsumptionLimitResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PendingConsumptionLimitResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PendingConsumptionLimitResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PendingConsumptionLimitResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline PendingConsumptionLimitResponse(const PendingConsumptionLimitResponse& from) : PendingConsumptionLimitResponse(nullptr, from) {}
  inline PendingConsumptionLimitResponse(PendingConsumptionLimitResponse&& from) noexcept
      : PendingConsumptionLimitResponse(nullptr, std::move(from)) {}
  inline PendingConsumptionLimitResponse& operator=(const PendingConsumptionLimitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PendingConsumptionLimitResponse& operator=(PendingConsumptionLimitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PendingConsumptionLimitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PendingConsumptionLimitResponse* internal_default_instance() {
    return reinterpret_cast<const PendingConsumptionLimitResponse*>(
        &_PendingConsumptionLimitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PendingConsumptionLimitResponse& a, PendingConsumptionLimitResponse& b) { a.Swap(&b); }
  inline void Swap(PendingConsumptionLimitResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PendingConsumptionLimitResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PendingConsumptionLimitResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PendingConsumptionLimitResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PendingConsumptionLimitResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PendingConsumptionLimitResponse& from) { PendingConsumptionLimitResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PendingConsumptionLimitResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "cs_lpc.PendingConsumptionLimitResponse"; }

 protected:
  explicit PendingConsumptionLimitResponse(::google::protobuf::Arena* arena);
  PendingConsumptionLimitResponse(::google::protobuf::Arena* arena, const PendingConsumptionLimitResponse& from);
  PendingConsumptionLimitResponse(::google::protobuf::Arena* arena, PendingConsumptionLimitResponse&& from) noexcept
      : PendingConsumptionLimitResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLoadLimitsFieldNumber = 1,
  };
  // map<uint64, .common_types.LoadLimit> load_limits = 1;
  int load_limits_size() const;
  private:
  int _internal_load_limits_size() const;

  public:
  void clear_load_limits() ;
  const ::google::protobuf::Map<::uint64_t, ::common_types::LoadLimit>& load_limits() const;
  ::google::protobuf::Map<::uint64_t, ::common_types::LoadLimit>* mutable_load_limits();

  private:
  const ::google::protobuf::Map<::uint64_t, ::common_types::LoadLimit>& _internal_load_limits() const;
  ::google::protobuf::Map<::uint64_t, ::common_types::LoadLimit>* _internal_mutable_load_limits();

  public:
  // @@protoc_insertion_point(class_scope:cs_lpc.PendingConsumptionLimitResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PendingConsumptionLimitResponse& from_msg);
    ::google::protobuf::internal::MapField<PendingConsumptionLimitResponse_LoadLimitsEntry_DoNotUse, ::uint64_t, ::common_types::LoadLimit,
                      ::google::protobuf::internal::WireFormatLite::TYPE_UINT64,
                      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE>
        load_limits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_usecases_2fcs_2flpc_2fmessages_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ConsumptionLimitRequest

// -------------------------------------------------------------------

// ConsumptionLimitResponse

// .common_types.LoadLimit load_limit = 1;
inline bool ConsumptionLimitResponse::has_load_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.load_limit_ != nullptr);
  return value;
}
inline const ::common_types::LoadLimit& ConsumptionLimitResponse::_internal_load_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::common_types::LoadLimit* p = _impl_.load_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::common_types::LoadLimit&>(::common_types::_LoadLimit_default_instance_);
}
inline const ::common_types::LoadLimit& ConsumptionLimitResponse::load_limit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cs_lpc.ConsumptionLimitResponse.load_limit)
  return _internal_load_limit();
}
inline void ConsumptionLimitResponse::unsafe_arena_set_allocated_load_limit(::common_types::LoadLimit* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.load_limit_);
  }
  _impl_.load_limit_ = reinterpret_cast<::common_types::LoadLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cs_lpc.ConsumptionLimitResponse.load_limit)
}
inline ::common_types::LoadLimit* ConsumptionLimitResponse::release_load_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common_types::LoadLimit* released = _impl_.load_limit_;
  _impl_.load_limit_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::common_types::LoadLimit* ConsumptionLimitResponse::unsafe_arena_release_load_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cs_lpc.ConsumptionLimitResponse.load_limit)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common_types::LoadLimit* temp = _impl_.load_limit_;
  _impl_.load_limit_ = nullptr;
  return temp;
}
inline ::common_types::LoadLimit* ConsumptionLimitResponse::_internal_mutable_load_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.load_limit_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::common_types::LoadLimit>(GetArena());
    _impl_.load_limit_ = reinterpret_cast<::common_types::LoadLimit*>(p);
  }
  return _impl_.load_limit_;
}
inline ::common_types::LoadLimit* ConsumptionLimitResponse::mutable_load_limit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::common_types::LoadLimit* _msg = _internal_mutable_load_limit();
  // @@protoc_insertion_point(field_mutable:cs_lpc.ConsumptionLimitResponse.load_limit)
  return _msg;
}
inline void ConsumptionLimitResponse::set_allocated_load_limit(::common_types::LoadLimit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.load_limit_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.load_limit_ = reinterpret_cast<::common_types::LoadLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:cs_lpc.ConsumptionLimitResponse.load_limit)
}

// -------------------------------------------------------------------

// SetConsumptionLimitRequest

// .common_types.LoadLimit load_limit = 1;
inline bool SetConsumptionLimitRequest::has_load_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.load_limit_ != nullptr);
  return value;
}
inline const ::common_types::LoadLimit& SetConsumptionLimitRequest::_internal_load_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::common_types::LoadLimit* p = _impl_.load_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::common_types::LoadLimit&>(::common_types::_LoadLimit_default_instance_);
}
inline const ::common_types::LoadLimit& SetConsumptionLimitRequest::load_limit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cs_lpc.SetConsumptionLimitRequest.load_limit)
  return _internal_load_limit();
}
inline void SetConsumptionLimitRequest::unsafe_arena_set_allocated_load_limit(::common_types::LoadLimit* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.load_limit_);
  }
  _impl_.load_limit_ = reinterpret_cast<::common_types::LoadLimit*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cs_lpc.SetConsumptionLimitRequest.load_limit)
}
inline ::common_types::LoadLimit* SetConsumptionLimitRequest::release_load_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common_types::LoadLimit* released = _impl_.load_limit_;
  _impl_.load_limit_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::common_types::LoadLimit* SetConsumptionLimitRequest::unsafe_arena_release_load_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cs_lpc.SetConsumptionLimitRequest.load_limit)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common_types::LoadLimit* temp = _impl_.load_limit_;
  _impl_.load_limit_ = nullptr;
  return temp;
}
inline ::common_types::LoadLimit* SetConsumptionLimitRequest::_internal_mutable_load_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.load_limit_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::common_types::LoadLimit>(GetArena());
    _impl_.load_limit_ = reinterpret_cast<::common_types::LoadLimit*>(p);
  }
  return _impl_.load_limit_;
}
inline ::common_types::LoadLimit* SetConsumptionLimitRequest::mutable_load_limit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::common_types::LoadLimit* _msg = _internal_mutable_load_limit();
  // @@protoc_insertion_point(field_mutable:cs_lpc.SetConsumptionLimitRequest.load_limit)
  return _msg;
}
inline void SetConsumptionLimitRequest::set_allocated_load_limit(::common_types::LoadLimit* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.load_limit_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.load_limit_ = reinterpret_cast<::common_types::LoadLimit*>(value);
  // @@protoc_insertion_point(field_set_allocated:cs_lpc.SetConsumptionLimitRequest.load_limit)
}

// -------------------------------------------------------------------

// SetConsumptionLimitResponse

// -------------------------------------------------------------------

// PendingConsumptionLimitRequest

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PendingConsumptionLimitResponse

// map<uint64, .common_types.LoadLimit> load_limits = 1;
inline int PendingConsumptionLimitResponse::_internal_load_limits_size() const {
  return _internal_load_limits().size();
}
inline int PendingConsumptionLimitResponse::load_limits_size() const {
  return _internal_load_limits_size();
}
inline const ::google::protobuf::Map<::uint64_t, ::common_types::LoadLimit>& PendingConsumptionLimitResponse::_internal_load_limits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.load_limits_.GetMap();
}
inline const ::google::protobuf::Map<::uint64_t, ::common_types::LoadLimit>& PendingConsumptionLimitResponse::load_limits() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:cs_lpc.PendingConsumptionLimitResponse.load_limits)
  return _internal_load_limits();
}
inline ::google::protobuf::Map<::uint64_t, ::common_types::LoadLimit>* PendingConsumptionLimitResponse::_internal_mutable_load_limits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.load_limits_.MutableMap();
}
inline ::google::protobuf::Map<::uint64_t, ::common_types::LoadLimit>* PendingConsumptionLimitResponse::mutable_load_limits() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:cs_lpc.PendingConsumptionLimitResponse.load_limits)
  return _internal_mutable_load_limits();
}

// -------------------------------------------------------------------

// ApproveOrDenyConsumptionLimitRequest

// uint64 msg_counter = 1;
inline void ApproveOrDenyConsumptionLimitRequest::clear_msg_counter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msg_counter_ = ::uint64_t{0u};
}
inline ::uint64_t ApproveOrDenyConsumptionLimitRequest::msg_counter() const {
  // @@protoc_insertion_point(field_get:cs_lpc.ApproveOrDenyConsumptionLimitRequest.msg_counter)
  return _internal_msg_counter();
}
inline void ApproveOrDenyConsumptionLimitRequest::set_msg_counter(::uint64_t value) {
  _internal_set_msg_counter(value);
  // @@protoc_insertion_point(field_set:cs_lpc.ApproveOrDenyConsumptionLimitRequest.msg_counter)
}
inline ::uint64_t ApproveOrDenyConsumptionLimitRequest::_internal_msg_counter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.msg_counter_;
}
inline void ApproveOrDenyConsumptionLimitRequest::_internal_set_msg_counter(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msg_counter_ = value;
}

// bool approve = 2;
inline void ApproveOrDenyConsumptionLimitRequest::clear_approve() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.approve_ = false;
}
inline bool ApproveOrDenyConsumptionLimitRequest::approve() const {
  // @@protoc_insertion_point(field_get:cs_lpc.ApproveOrDenyConsumptionLimitRequest.approve)
  return _internal_approve();
}
inline void ApproveOrDenyConsumptionLimitRequest::set_approve(bool value) {
  _internal_set_approve(value);
  // @@protoc_insertion_point(field_set:cs_lpc.ApproveOrDenyConsumptionLimitRequest.approve)
}
inline bool ApproveOrDenyConsumptionLimitRequest::_internal_approve() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.approve_;
}
inline void ApproveOrDenyConsumptionLimitRequest::_internal_set_approve(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.approve_ = value;
}

// string reason = 3;
inline void ApproveOrDenyConsumptionLimitRequest::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& ApproveOrDenyConsumptionLimitRequest::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cs_lpc.ApproveOrDenyConsumptionLimitRequest.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ApproveOrDenyConsumptionLimitRequest::set_reason(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:cs_lpc.ApproveOrDenyConsumptionLimitRequest.reason)
}
inline std::string* ApproveOrDenyConsumptionLimitRequest::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:cs_lpc.ApproveOrDenyConsumptionLimitRequest.reason)
  return _s;
}
inline const std::string& ApproveOrDenyConsumptionLimitRequest::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_.Get();
}
inline void ApproveOrDenyConsumptionLimitRequest::_internal_set_reason(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* ApproveOrDenyConsumptionLimitRequest::_internal_mutable_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* ApproveOrDenyConsumptionLimitRequest::release_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:cs_lpc.ApproveOrDenyConsumptionLimitRequest.reason)
  return _impl_.reason_.Release();
}
inline void ApproveOrDenyConsumptionLimitRequest::set_allocated_reason(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.reason_.IsDefault()) {
    _impl_.reason_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:cs_lpc.ApproveOrDenyConsumptionLimitRequest.reason)
}

// -------------------------------------------------------------------

// ApproveOrDenyConsumptionLimitResponse

// -------------------------------------------------------------------

// FailsafeConsumptionActivePowerLimitRequest

// -------------------------------------------------------------------

// FailsafeConsumptionActivePowerLimitResponse

// double limit = 1;
inline void FailsafeConsumptionActivePowerLimitResponse::clear_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = 0;
}
inline double FailsafeConsumptionActivePowerLimitResponse::limit() const {
  // @@protoc_insertion_point(field_get:cs_lpc.FailsafeConsumptionActivePowerLimitResponse.limit)
  return _internal_limit();
}
inline void FailsafeConsumptionActivePowerLimitResponse::set_limit(double value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:cs_lpc.FailsafeConsumptionActivePowerLimitResponse.limit)
}
inline double FailsafeConsumptionActivePowerLimitResponse::_internal_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.limit_;
}
inline void FailsafeConsumptionActivePowerLimitResponse::_internal_set_limit(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.limit_ = value;
}

// bool is_changeable = 2;
inline void FailsafeConsumptionActivePowerLimitResponse::clear_is_changeable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_changeable_ = false;
}
inline bool FailsafeConsumptionActivePowerLimitResponse::is_changeable() const {
  // @@protoc_insertion_point(field_get:cs_lpc.FailsafeConsumptionActivePowerLimitResponse.is_changeable)
  return _internal_is_changeable();
}
inline void FailsafeConsumptionActivePowerLimitResponse::set_is_changeable(bool value) {
  _internal_set_is_changeable(value);
  // @@protoc_insertion_point(field_set:cs_lpc.FailsafeConsumptionActivePowerLimitResponse.is_changeable)
}
inline bool FailsafeConsumptionActivePowerLimitResponse::_internal_is_changeable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_changeable_;
}
inline void FailsafeConsumptionActivePowerLimitResponse::_internal_set_is_changeable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_changeable_ = value;
}

// -------------------------------------------------------------------

// SetFailsafeConsumptionActivePowerLimitRequest

// double value = 1;
inline void SetFailsafeConsumptionActivePowerLimitRequest::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
}
inline double SetFailsafeConsumptionActivePowerLimitRequest::value() const {
  // @@protoc_insertion_point(field_get:cs_lpc.SetFailsafeConsumptionActivePowerLimitRequest.value)
  return _internal_value();
}
inline void SetFailsafeConsumptionActivePowerLimitRequest::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cs_lpc.SetFailsafeConsumptionActivePowerLimitRequest.value)
}
inline double SetFailsafeConsumptionActivePowerLimitRequest::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void SetFailsafeConsumptionActivePowerLimitRequest::_internal_set_value(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// bool is_changeable = 2;
inline void SetFailsafeConsumptionActivePowerLimitRequest::clear_is_changeable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_changeable_ = false;
}
inline bool SetFailsafeConsumptionActivePowerLimitRequest::is_changeable() const {
  // @@protoc_insertion_point(field_get:cs_lpc.SetFailsafeConsumptionActivePowerLimitRequest.is_changeable)
  return _internal_is_changeable();
}
inline void SetFailsafeConsumptionActivePowerLimitRequest::set_is_changeable(bool value) {
  _internal_set_is_changeable(value);
  // @@protoc_insertion_point(field_set:cs_lpc.SetFailsafeConsumptionActivePowerLimitRequest.is_changeable)
}
inline bool SetFailsafeConsumptionActivePowerLimitRequest::_internal_is_changeable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_changeable_;
}
inline void SetFailsafeConsumptionActivePowerLimitRequest::_internal_set_is_changeable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_changeable_ = value;
}

// -------------------------------------------------------------------

// SetFailsafeConsumptionActivePowerLimitResponse

// -------------------------------------------------------------------

// FailsafeDurationMinimumRequest

// -------------------------------------------------------------------

// FailsafeDurationMinimumResponse

// int64 duration_nanoseconds = 1;
inline void FailsafeDurationMinimumResponse::clear_duration_nanoseconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_nanoseconds_ = ::int64_t{0};
}
inline ::int64_t FailsafeDurationMinimumResponse::duration_nanoseconds() const {
  // @@protoc_insertion_point(field_get:cs_lpc.FailsafeDurationMinimumResponse.duration_nanoseconds)
  return _internal_duration_nanoseconds();
}
inline void FailsafeDurationMinimumResponse::set_duration_nanoseconds(::int64_t value) {
  _internal_set_duration_nanoseconds(value);
  // @@protoc_insertion_point(field_set:cs_lpc.FailsafeDurationMinimumResponse.duration_nanoseconds)
}
inline ::int64_t FailsafeDurationMinimumResponse::_internal_duration_nanoseconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duration_nanoseconds_;
}
inline void FailsafeDurationMinimumResponse::_internal_set_duration_nanoseconds(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_nanoseconds_ = value;
}

// bool is_changeable = 2;
inline void FailsafeDurationMinimumResponse::clear_is_changeable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_changeable_ = false;
}
inline bool FailsafeDurationMinimumResponse::is_changeable() const {
  // @@protoc_insertion_point(field_get:cs_lpc.FailsafeDurationMinimumResponse.is_changeable)
  return _internal_is_changeable();
}
inline void FailsafeDurationMinimumResponse::set_is_changeable(bool value) {
  _internal_set_is_changeable(value);
  // @@protoc_insertion_point(field_set:cs_lpc.FailsafeDurationMinimumResponse.is_changeable)
}
inline bool FailsafeDurationMinimumResponse::_internal_is_changeable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_changeable_;
}
inline void FailsafeDurationMinimumResponse::_internal_set_is_changeable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_changeable_ = value;
}

// -------------------------------------------------------------------

// SetFailsafeDurationMinimumRequest

// int64 duration_nanoseconds = 1;
inline void SetFailsafeDurationMinimumRequest::clear_duration_nanoseconds() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_nanoseconds_ = ::int64_t{0};
}
inline ::int64_t SetFailsafeDurationMinimumRequest::duration_nanoseconds() const {
  // @@protoc_insertion_point(field_get:cs_lpc.SetFailsafeDurationMinimumRequest.duration_nanoseconds)
  return _internal_duration_nanoseconds();
}
inline void SetFailsafeDurationMinimumRequest::set_duration_nanoseconds(::int64_t value) {
  _internal_set_duration_nanoseconds(value);
  // @@protoc_insertion_point(field_set:cs_lpc.SetFailsafeDurationMinimumRequest.duration_nanoseconds)
}
inline ::int64_t SetFailsafeDurationMinimumRequest::_internal_duration_nanoseconds() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.duration_nanoseconds_;
}
inline void SetFailsafeDurationMinimumRequest::_internal_set_duration_nanoseconds(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.duration_nanoseconds_ = value;
}

// bool is_changeable = 2;
inline void SetFailsafeDurationMinimumRequest::clear_is_changeable() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_changeable_ = false;
}
inline bool SetFailsafeDurationMinimumRequest::is_changeable() const {
  // @@protoc_insertion_point(field_get:cs_lpc.SetFailsafeDurationMinimumRequest.is_changeable)
  return _internal_is_changeable();
}
inline void SetFailsafeDurationMinimumRequest::set_is_changeable(bool value) {
  _internal_set_is_changeable(value);
  // @@protoc_insertion_point(field_set:cs_lpc.SetFailsafeDurationMinimumRequest.is_changeable)
}
inline bool SetFailsafeDurationMinimumRequest::_internal_is_changeable() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_changeable_;
}
inline void SetFailsafeDurationMinimumRequest::_internal_set_is_changeable(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_changeable_ = value;
}

// -------------------------------------------------------------------

// SetFailsafeDurationMinimumResponse

// -------------------------------------------------------------------

// StartHeartbeatRequest

// -------------------------------------------------------------------

// StartHeartbeatResponse

// -------------------------------------------------------------------

// StopHeartbeatRequest

// -------------------------------------------------------------------

// StopHeartbeatResponse

// -------------------------------------------------------------------

// IsHeartbeatWithinDurationRequest

// -------------------------------------------------------------------

// IsHeartbeatWithinDurationResponse

// bool is_within_duration = 1;
inline void IsHeartbeatWithinDurationResponse::clear_is_within_duration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_within_duration_ = false;
}
inline bool IsHeartbeatWithinDurationResponse::is_within_duration() const {
  // @@protoc_insertion_point(field_get:cs_lpc.IsHeartbeatWithinDurationResponse.is_within_duration)
  return _internal_is_within_duration();
}
inline void IsHeartbeatWithinDurationResponse::set_is_within_duration(bool value) {
  _internal_set_is_within_duration(value);
  // @@protoc_insertion_point(field_set:cs_lpc.IsHeartbeatWithinDurationResponse.is_within_duration)
}
inline bool IsHeartbeatWithinDurationResponse::_internal_is_within_duration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_within_duration_;
}
inline void IsHeartbeatWithinDurationResponse::_internal_set_is_within_duration(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_within_duration_ = value;
}

// -------------------------------------------------------------------

// ConsumptionNominalMaxRequest

// -------------------------------------------------------------------

// ConsumptionNominalMaxResponse

// double value = 1;
inline void ConsumptionNominalMaxResponse::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
}
inline double ConsumptionNominalMaxResponse::value() const {
  // @@protoc_insertion_point(field_get:cs_lpc.ConsumptionNominalMaxResponse.value)
  return _internal_value();
}
inline void ConsumptionNominalMaxResponse::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cs_lpc.ConsumptionNominalMaxResponse.value)
}
inline double ConsumptionNominalMaxResponse::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void ConsumptionNominalMaxResponse::_internal_set_value(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// SetConsumptionNominalMaxRequest

// double value = 1;
inline void SetConsumptionNominalMaxRequest::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = 0;
}
inline double SetConsumptionNominalMaxRequest::value() const {
  // @@protoc_insertion_point(field_get:cs_lpc.SetConsumptionNominalMaxRequest.value)
  return _internal_value();
}
inline void SetConsumptionNominalMaxRequest::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cs_lpc.SetConsumptionNominalMaxRequest.value)
}
inline double SetConsumptionNominalMaxRequest::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void SetConsumptionNominalMaxRequest::_internal_set_value(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// SetConsumptionNominalMaxResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

ConsumptionLimitRequest CreateConsumptionLimitRequest();

ConsumptionLimitResponse CreateConsumptionLimitResponse(
    common_types::LoadLimit* load_limit);

SetConsumptionLimitRequest CreateSetConsumptionLimitRequest(
    common_types::LoadLimit* load_limit);

SetConsumptionLimitResponse CreateSetConsumptionLimitResponse();

PendingConsumptionLimitRequest CreatePendingConsumptionLimitRequest();

PendingConsumptionLimitResponse CreatePendingConsumptionLimitResponse(
    std::map<uint64_t, common_types::LoadLimit> load_limits);

ApproveOrDenyConsumptionLimitRequest CreateApproveOrDenyConsumptionLimitRequest(
    uint64_t msg_counter,
    bool approve,
    std::string reason);

ApproveOrDenyConsumptionLimitResponse CreateApproveOrDenyConsumptionLimitResponse();

FailsafeConsumptionActivePowerLimitRequest CreateFailsafeConsumptionActivePowerLimitRequest();

FailsafeConsumptionActivePowerLimitResponse CreateFailsafeConsumptionActivePowerLimitResponse(
    double limit,
    bool is_changeable);

SetFailsafeConsumptionActivePowerLimitRequest CreateSetFailsafeConsumptionActivePowerLimitRequest(
    double value,
    bool is_changeable);

SetFailsafeConsumptionActivePowerLimitResponse CreateSetFailsafeConsumptionActivePowerLimitResponse();

FailsafeDurationMinimumRequest CreateFailsafeDurationMinimumRequest();

FailsafeDurationMinimumResponse CreateFailsafeDurationMinimumResponse(
    int64_t duration_nanoseconds,
    bool is_changeable);

SetFailsafeDurationMinimumRequest CreateSetFailsafeDurationMinimumRequest(
    int64_t duration_nanoseconds,
    bool is_changeable);

SetFailsafeDurationMinimumResponse CreateSetFailsafeDurationMinimumResponse();

StartHeartbeatRequest CreateStartHeartbeatRequest();

StartHeartbeatResponse CreateStartHeartbeatResponse();

StopHeartbeatRequest CreateStopHeartbeatRequest();

StopHeartbeatResponse CreateStopHeartbeatResponse();

IsHeartbeatWithinDurationRequest CreateIsHeartbeatWithinDurationRequest();

IsHeartbeatWithinDurationResponse CreateIsHeartbeatWithinDurationResponse(
    bool is_within_duration);

ConsumptionNominalMaxRequest CreateConsumptionNominalMaxRequest();

ConsumptionNominalMaxResponse CreateConsumptionNominalMaxResponse(
    double value);

SetConsumptionNominalMaxRequest CreateSetConsumptionNominalMaxRequest(
    double value);

SetConsumptionNominalMaxResponse CreateSetConsumptionNominalMaxResponse();

// @@protoc_insertion_point(namespace_scope)
}  // namespace cs_lpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // usecases_2fcs_2flpc_2fmessages_2eproto_2epb_2eh
