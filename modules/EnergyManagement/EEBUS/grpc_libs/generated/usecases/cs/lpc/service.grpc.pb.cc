// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: usecases/cs/lpc/service.proto

#include "usecases/cs/lpc/service.pb.h"
#include "usecases/cs/lpc/service.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/channel_interface.h>
#include <grpcpp/impl/client_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/rpc_service_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/sync_stream.h>
namespace cs_lpc {

static const char* ControllableSystemLPCControl_method_names[] = {
  "/cs_lpc.ControllableSystemLPCControl/ConsumptionLimit",
  "/cs_lpc.ControllableSystemLPCControl/SetConsumptionLimit",
  "/cs_lpc.ControllableSystemLPCControl/PendingConsumptionLimit",
  "/cs_lpc.ControllableSystemLPCControl/ApproveOrDenyConsumptionLimit",
  "/cs_lpc.ControllableSystemLPCControl/FailsafeConsumptionActivePowerLimit",
  "/cs_lpc.ControllableSystemLPCControl/SetFailsafeConsumptionActivePowerLimit",
  "/cs_lpc.ControllableSystemLPCControl/FailsafeDurationMinimum",
  "/cs_lpc.ControllableSystemLPCControl/SetFailsafeDurationMinimum",
  "/cs_lpc.ControllableSystemLPCControl/StartHeartbeat",
  "/cs_lpc.ControllableSystemLPCControl/StopHeartbeat",
  "/cs_lpc.ControllableSystemLPCControl/IsHeartbeatWithinDuration",
  "/cs_lpc.ControllableSystemLPCControl/ConsumptionNominalMax",
  "/cs_lpc.ControllableSystemLPCControl/SetConsumptionNominalMax",
};

std::unique_ptr< ControllableSystemLPCControl::Stub> ControllableSystemLPCControl::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< ControllableSystemLPCControl::Stub> stub(new ControllableSystemLPCControl::Stub(channel, options));
  return stub;
}

ControllableSystemLPCControl::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_ConsumptionLimit_(ControllableSystemLPCControl_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetConsumptionLimit_(ControllableSystemLPCControl_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_PendingConsumptionLimit_(ControllableSystemLPCControl_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ApproveOrDenyConsumptionLimit_(ControllableSystemLPCControl_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_FailsafeConsumptionActivePowerLimit_(ControllableSystemLPCControl_method_names[4], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetFailsafeConsumptionActivePowerLimit_(ControllableSystemLPCControl_method_names[5], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_FailsafeDurationMinimum_(ControllableSystemLPCControl_method_names[6], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetFailsafeDurationMinimum_(ControllableSystemLPCControl_method_names[7], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_StartHeartbeat_(ControllableSystemLPCControl_method_names[8], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_StopHeartbeat_(ControllableSystemLPCControl_method_names[9], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_IsHeartbeatWithinDuration_(ControllableSystemLPCControl_method_names[10], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ConsumptionNominalMax_(ControllableSystemLPCControl_method_names[11], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SetConsumptionNominalMax_(ControllableSystemLPCControl_method_names[12], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status ControllableSystemLPCControl::Stub::ConsumptionLimit(::grpc::ClientContext* context, const ::cs_lpc::ConsumptionLimitRequest& request, ::cs_lpc::ConsumptionLimitResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::cs_lpc::ConsumptionLimitRequest, ::cs_lpc::ConsumptionLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ConsumptionLimit_, context, request, response);
}

void ControllableSystemLPCControl::Stub::async::ConsumptionLimit(::grpc::ClientContext* context, const ::cs_lpc::ConsumptionLimitRequest* request, ::cs_lpc::ConsumptionLimitResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::cs_lpc::ConsumptionLimitRequest, ::cs_lpc::ConsumptionLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ConsumptionLimit_, context, request, response, std::move(f));
}

void ControllableSystemLPCControl::Stub::async::ConsumptionLimit(::grpc::ClientContext* context, const ::cs_lpc::ConsumptionLimitRequest* request, ::cs_lpc::ConsumptionLimitResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ConsumptionLimit_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::ConsumptionLimitResponse>* ControllableSystemLPCControl::Stub::PrepareAsyncConsumptionLimitRaw(::grpc::ClientContext* context, const ::cs_lpc::ConsumptionLimitRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::cs_lpc::ConsumptionLimitResponse, ::cs_lpc::ConsumptionLimitRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ConsumptionLimit_, context, request);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::ConsumptionLimitResponse>* ControllableSystemLPCControl::Stub::AsyncConsumptionLimitRaw(::grpc::ClientContext* context, const ::cs_lpc::ConsumptionLimitRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncConsumptionLimitRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ControllableSystemLPCControl::Stub::SetConsumptionLimit(::grpc::ClientContext* context, const ::cs_lpc::SetConsumptionLimitRequest& request, ::cs_lpc::SetConsumptionLimitResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::cs_lpc::SetConsumptionLimitRequest, ::cs_lpc::SetConsumptionLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SetConsumptionLimit_, context, request, response);
}

void ControllableSystemLPCControl::Stub::async::SetConsumptionLimit(::grpc::ClientContext* context, const ::cs_lpc::SetConsumptionLimitRequest* request, ::cs_lpc::SetConsumptionLimitResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::cs_lpc::SetConsumptionLimitRequest, ::cs_lpc::SetConsumptionLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SetConsumptionLimit_, context, request, response, std::move(f));
}

void ControllableSystemLPCControl::Stub::async::SetConsumptionLimit(::grpc::ClientContext* context, const ::cs_lpc::SetConsumptionLimitRequest* request, ::cs_lpc::SetConsumptionLimitResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SetConsumptionLimit_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::SetConsumptionLimitResponse>* ControllableSystemLPCControl::Stub::PrepareAsyncSetConsumptionLimitRaw(::grpc::ClientContext* context, const ::cs_lpc::SetConsumptionLimitRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::cs_lpc::SetConsumptionLimitResponse, ::cs_lpc::SetConsumptionLimitRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SetConsumptionLimit_, context, request);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::SetConsumptionLimitResponse>* ControllableSystemLPCControl::Stub::AsyncSetConsumptionLimitRaw(::grpc::ClientContext* context, const ::cs_lpc::SetConsumptionLimitRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSetConsumptionLimitRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ControllableSystemLPCControl::Stub::PendingConsumptionLimit(::grpc::ClientContext* context, const ::cs_lpc::PendingConsumptionLimitRequest& request, ::cs_lpc::PendingConsumptionLimitResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::cs_lpc::PendingConsumptionLimitRequest, ::cs_lpc::PendingConsumptionLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_PendingConsumptionLimit_, context, request, response);
}

void ControllableSystemLPCControl::Stub::async::PendingConsumptionLimit(::grpc::ClientContext* context, const ::cs_lpc::PendingConsumptionLimitRequest* request, ::cs_lpc::PendingConsumptionLimitResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::cs_lpc::PendingConsumptionLimitRequest, ::cs_lpc::PendingConsumptionLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_PendingConsumptionLimit_, context, request, response, std::move(f));
}

void ControllableSystemLPCControl::Stub::async::PendingConsumptionLimit(::grpc::ClientContext* context, const ::cs_lpc::PendingConsumptionLimitRequest* request, ::cs_lpc::PendingConsumptionLimitResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_PendingConsumptionLimit_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::PendingConsumptionLimitResponse>* ControllableSystemLPCControl::Stub::PrepareAsyncPendingConsumptionLimitRaw(::grpc::ClientContext* context, const ::cs_lpc::PendingConsumptionLimitRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::cs_lpc::PendingConsumptionLimitResponse, ::cs_lpc::PendingConsumptionLimitRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_PendingConsumptionLimit_, context, request);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::PendingConsumptionLimitResponse>* ControllableSystemLPCControl::Stub::AsyncPendingConsumptionLimitRaw(::grpc::ClientContext* context, const ::cs_lpc::PendingConsumptionLimitRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncPendingConsumptionLimitRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ControllableSystemLPCControl::Stub::ApproveOrDenyConsumptionLimit(::grpc::ClientContext* context, const ::cs_lpc::ApproveOrDenyConsumptionLimitRequest& request, ::cs_lpc::ApproveOrDenyConsumptionLimitResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::cs_lpc::ApproveOrDenyConsumptionLimitRequest, ::cs_lpc::ApproveOrDenyConsumptionLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ApproveOrDenyConsumptionLimit_, context, request, response);
}

void ControllableSystemLPCControl::Stub::async::ApproveOrDenyConsumptionLimit(::grpc::ClientContext* context, const ::cs_lpc::ApproveOrDenyConsumptionLimitRequest* request, ::cs_lpc::ApproveOrDenyConsumptionLimitResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::cs_lpc::ApproveOrDenyConsumptionLimitRequest, ::cs_lpc::ApproveOrDenyConsumptionLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ApproveOrDenyConsumptionLimit_, context, request, response, std::move(f));
}

void ControllableSystemLPCControl::Stub::async::ApproveOrDenyConsumptionLimit(::grpc::ClientContext* context, const ::cs_lpc::ApproveOrDenyConsumptionLimitRequest* request, ::cs_lpc::ApproveOrDenyConsumptionLimitResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ApproveOrDenyConsumptionLimit_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::ApproveOrDenyConsumptionLimitResponse>* ControllableSystemLPCControl::Stub::PrepareAsyncApproveOrDenyConsumptionLimitRaw(::grpc::ClientContext* context, const ::cs_lpc::ApproveOrDenyConsumptionLimitRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::cs_lpc::ApproveOrDenyConsumptionLimitResponse, ::cs_lpc::ApproveOrDenyConsumptionLimitRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ApproveOrDenyConsumptionLimit_, context, request);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::ApproveOrDenyConsumptionLimitResponse>* ControllableSystemLPCControl::Stub::AsyncApproveOrDenyConsumptionLimitRaw(::grpc::ClientContext* context, const ::cs_lpc::ApproveOrDenyConsumptionLimitRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncApproveOrDenyConsumptionLimitRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ControllableSystemLPCControl::Stub::FailsafeConsumptionActivePowerLimit(::grpc::ClientContext* context, const ::cs_lpc::FailsafeConsumptionActivePowerLimitRequest& request, ::cs_lpc::FailsafeConsumptionActivePowerLimitResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::cs_lpc::FailsafeConsumptionActivePowerLimitRequest, ::cs_lpc::FailsafeConsumptionActivePowerLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_FailsafeConsumptionActivePowerLimit_, context, request, response);
}

void ControllableSystemLPCControl::Stub::async::FailsafeConsumptionActivePowerLimit(::grpc::ClientContext* context, const ::cs_lpc::FailsafeConsumptionActivePowerLimitRequest* request, ::cs_lpc::FailsafeConsumptionActivePowerLimitResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::cs_lpc::FailsafeConsumptionActivePowerLimitRequest, ::cs_lpc::FailsafeConsumptionActivePowerLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_FailsafeConsumptionActivePowerLimit_, context, request, response, std::move(f));
}

void ControllableSystemLPCControl::Stub::async::FailsafeConsumptionActivePowerLimit(::grpc::ClientContext* context, const ::cs_lpc::FailsafeConsumptionActivePowerLimitRequest* request, ::cs_lpc::FailsafeConsumptionActivePowerLimitResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_FailsafeConsumptionActivePowerLimit_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::FailsafeConsumptionActivePowerLimitResponse>* ControllableSystemLPCControl::Stub::PrepareAsyncFailsafeConsumptionActivePowerLimitRaw(::grpc::ClientContext* context, const ::cs_lpc::FailsafeConsumptionActivePowerLimitRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::cs_lpc::FailsafeConsumptionActivePowerLimitResponse, ::cs_lpc::FailsafeConsumptionActivePowerLimitRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_FailsafeConsumptionActivePowerLimit_, context, request);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::FailsafeConsumptionActivePowerLimitResponse>* ControllableSystemLPCControl::Stub::AsyncFailsafeConsumptionActivePowerLimitRaw(::grpc::ClientContext* context, const ::cs_lpc::FailsafeConsumptionActivePowerLimitRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncFailsafeConsumptionActivePowerLimitRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ControllableSystemLPCControl::Stub::SetFailsafeConsumptionActivePowerLimit(::grpc::ClientContext* context, const ::cs_lpc::SetFailsafeConsumptionActivePowerLimitRequest& request, ::cs_lpc::SetFailsafeConsumptionActivePowerLimitResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::cs_lpc::SetFailsafeConsumptionActivePowerLimitRequest, ::cs_lpc::SetFailsafeConsumptionActivePowerLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SetFailsafeConsumptionActivePowerLimit_, context, request, response);
}

void ControllableSystemLPCControl::Stub::async::SetFailsafeConsumptionActivePowerLimit(::grpc::ClientContext* context, const ::cs_lpc::SetFailsafeConsumptionActivePowerLimitRequest* request, ::cs_lpc::SetFailsafeConsumptionActivePowerLimitResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::cs_lpc::SetFailsafeConsumptionActivePowerLimitRequest, ::cs_lpc::SetFailsafeConsumptionActivePowerLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SetFailsafeConsumptionActivePowerLimit_, context, request, response, std::move(f));
}

void ControllableSystemLPCControl::Stub::async::SetFailsafeConsumptionActivePowerLimit(::grpc::ClientContext* context, const ::cs_lpc::SetFailsafeConsumptionActivePowerLimitRequest* request, ::cs_lpc::SetFailsafeConsumptionActivePowerLimitResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SetFailsafeConsumptionActivePowerLimit_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::SetFailsafeConsumptionActivePowerLimitResponse>* ControllableSystemLPCControl::Stub::PrepareAsyncSetFailsafeConsumptionActivePowerLimitRaw(::grpc::ClientContext* context, const ::cs_lpc::SetFailsafeConsumptionActivePowerLimitRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::cs_lpc::SetFailsafeConsumptionActivePowerLimitResponse, ::cs_lpc::SetFailsafeConsumptionActivePowerLimitRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SetFailsafeConsumptionActivePowerLimit_, context, request);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::SetFailsafeConsumptionActivePowerLimitResponse>* ControllableSystemLPCControl::Stub::AsyncSetFailsafeConsumptionActivePowerLimitRaw(::grpc::ClientContext* context, const ::cs_lpc::SetFailsafeConsumptionActivePowerLimitRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSetFailsafeConsumptionActivePowerLimitRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ControllableSystemLPCControl::Stub::FailsafeDurationMinimum(::grpc::ClientContext* context, const ::cs_lpc::FailsafeDurationMinimumRequest& request, ::cs_lpc::FailsafeDurationMinimumResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::cs_lpc::FailsafeDurationMinimumRequest, ::cs_lpc::FailsafeDurationMinimumResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_FailsafeDurationMinimum_, context, request, response);
}

void ControllableSystemLPCControl::Stub::async::FailsafeDurationMinimum(::grpc::ClientContext* context, const ::cs_lpc::FailsafeDurationMinimumRequest* request, ::cs_lpc::FailsafeDurationMinimumResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::cs_lpc::FailsafeDurationMinimumRequest, ::cs_lpc::FailsafeDurationMinimumResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_FailsafeDurationMinimum_, context, request, response, std::move(f));
}

void ControllableSystemLPCControl::Stub::async::FailsafeDurationMinimum(::grpc::ClientContext* context, const ::cs_lpc::FailsafeDurationMinimumRequest* request, ::cs_lpc::FailsafeDurationMinimumResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_FailsafeDurationMinimum_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::FailsafeDurationMinimumResponse>* ControllableSystemLPCControl::Stub::PrepareAsyncFailsafeDurationMinimumRaw(::grpc::ClientContext* context, const ::cs_lpc::FailsafeDurationMinimumRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::cs_lpc::FailsafeDurationMinimumResponse, ::cs_lpc::FailsafeDurationMinimumRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_FailsafeDurationMinimum_, context, request);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::FailsafeDurationMinimumResponse>* ControllableSystemLPCControl::Stub::AsyncFailsafeDurationMinimumRaw(::grpc::ClientContext* context, const ::cs_lpc::FailsafeDurationMinimumRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncFailsafeDurationMinimumRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ControllableSystemLPCControl::Stub::SetFailsafeDurationMinimum(::grpc::ClientContext* context, const ::cs_lpc::SetFailsafeDurationMinimumRequest& request, ::cs_lpc::SetFailsafeDurationMinimumResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::cs_lpc::SetFailsafeDurationMinimumRequest, ::cs_lpc::SetFailsafeDurationMinimumResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SetFailsafeDurationMinimum_, context, request, response);
}

void ControllableSystemLPCControl::Stub::async::SetFailsafeDurationMinimum(::grpc::ClientContext* context, const ::cs_lpc::SetFailsafeDurationMinimumRequest* request, ::cs_lpc::SetFailsafeDurationMinimumResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::cs_lpc::SetFailsafeDurationMinimumRequest, ::cs_lpc::SetFailsafeDurationMinimumResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SetFailsafeDurationMinimum_, context, request, response, std::move(f));
}

void ControllableSystemLPCControl::Stub::async::SetFailsafeDurationMinimum(::grpc::ClientContext* context, const ::cs_lpc::SetFailsafeDurationMinimumRequest* request, ::cs_lpc::SetFailsafeDurationMinimumResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SetFailsafeDurationMinimum_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::SetFailsafeDurationMinimumResponse>* ControllableSystemLPCControl::Stub::PrepareAsyncSetFailsafeDurationMinimumRaw(::grpc::ClientContext* context, const ::cs_lpc::SetFailsafeDurationMinimumRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::cs_lpc::SetFailsafeDurationMinimumResponse, ::cs_lpc::SetFailsafeDurationMinimumRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SetFailsafeDurationMinimum_, context, request);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::SetFailsafeDurationMinimumResponse>* ControllableSystemLPCControl::Stub::AsyncSetFailsafeDurationMinimumRaw(::grpc::ClientContext* context, const ::cs_lpc::SetFailsafeDurationMinimumRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSetFailsafeDurationMinimumRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ControllableSystemLPCControl::Stub::StartHeartbeat(::grpc::ClientContext* context, const ::cs_lpc::StartHeartbeatRequest& request, ::cs_lpc::StartHeartbeatResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::cs_lpc::StartHeartbeatRequest, ::cs_lpc::StartHeartbeatResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_StartHeartbeat_, context, request, response);
}

void ControllableSystemLPCControl::Stub::async::StartHeartbeat(::grpc::ClientContext* context, const ::cs_lpc::StartHeartbeatRequest* request, ::cs_lpc::StartHeartbeatResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::cs_lpc::StartHeartbeatRequest, ::cs_lpc::StartHeartbeatResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_StartHeartbeat_, context, request, response, std::move(f));
}

void ControllableSystemLPCControl::Stub::async::StartHeartbeat(::grpc::ClientContext* context, const ::cs_lpc::StartHeartbeatRequest* request, ::cs_lpc::StartHeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_StartHeartbeat_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::StartHeartbeatResponse>* ControllableSystemLPCControl::Stub::PrepareAsyncStartHeartbeatRaw(::grpc::ClientContext* context, const ::cs_lpc::StartHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::cs_lpc::StartHeartbeatResponse, ::cs_lpc::StartHeartbeatRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_StartHeartbeat_, context, request);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::StartHeartbeatResponse>* ControllableSystemLPCControl::Stub::AsyncStartHeartbeatRaw(::grpc::ClientContext* context, const ::cs_lpc::StartHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncStartHeartbeatRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ControllableSystemLPCControl::Stub::StopHeartbeat(::grpc::ClientContext* context, const ::cs_lpc::StopHeartbeatRequest& request, ::cs_lpc::StopHeartbeatResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::cs_lpc::StopHeartbeatRequest, ::cs_lpc::StopHeartbeatResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_StopHeartbeat_, context, request, response);
}

void ControllableSystemLPCControl::Stub::async::StopHeartbeat(::grpc::ClientContext* context, const ::cs_lpc::StopHeartbeatRequest* request, ::cs_lpc::StopHeartbeatResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::cs_lpc::StopHeartbeatRequest, ::cs_lpc::StopHeartbeatResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_StopHeartbeat_, context, request, response, std::move(f));
}

void ControllableSystemLPCControl::Stub::async::StopHeartbeat(::grpc::ClientContext* context, const ::cs_lpc::StopHeartbeatRequest* request, ::cs_lpc::StopHeartbeatResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_StopHeartbeat_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::StopHeartbeatResponse>* ControllableSystemLPCControl::Stub::PrepareAsyncStopHeartbeatRaw(::grpc::ClientContext* context, const ::cs_lpc::StopHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::cs_lpc::StopHeartbeatResponse, ::cs_lpc::StopHeartbeatRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_StopHeartbeat_, context, request);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::StopHeartbeatResponse>* ControllableSystemLPCControl::Stub::AsyncStopHeartbeatRaw(::grpc::ClientContext* context, const ::cs_lpc::StopHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncStopHeartbeatRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ControllableSystemLPCControl::Stub::IsHeartbeatWithinDuration(::grpc::ClientContext* context, const ::cs_lpc::IsHeartbeatWithinDurationRequest& request, ::cs_lpc::IsHeartbeatWithinDurationResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::cs_lpc::IsHeartbeatWithinDurationRequest, ::cs_lpc::IsHeartbeatWithinDurationResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_IsHeartbeatWithinDuration_, context, request, response);
}

void ControllableSystemLPCControl::Stub::async::IsHeartbeatWithinDuration(::grpc::ClientContext* context, const ::cs_lpc::IsHeartbeatWithinDurationRequest* request, ::cs_lpc::IsHeartbeatWithinDurationResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::cs_lpc::IsHeartbeatWithinDurationRequest, ::cs_lpc::IsHeartbeatWithinDurationResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_IsHeartbeatWithinDuration_, context, request, response, std::move(f));
}

void ControllableSystemLPCControl::Stub::async::IsHeartbeatWithinDuration(::grpc::ClientContext* context, const ::cs_lpc::IsHeartbeatWithinDurationRequest* request, ::cs_lpc::IsHeartbeatWithinDurationResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_IsHeartbeatWithinDuration_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::IsHeartbeatWithinDurationResponse>* ControllableSystemLPCControl::Stub::PrepareAsyncIsHeartbeatWithinDurationRaw(::grpc::ClientContext* context, const ::cs_lpc::IsHeartbeatWithinDurationRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::cs_lpc::IsHeartbeatWithinDurationResponse, ::cs_lpc::IsHeartbeatWithinDurationRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_IsHeartbeatWithinDuration_, context, request);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::IsHeartbeatWithinDurationResponse>* ControllableSystemLPCControl::Stub::AsyncIsHeartbeatWithinDurationRaw(::grpc::ClientContext* context, const ::cs_lpc::IsHeartbeatWithinDurationRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncIsHeartbeatWithinDurationRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ControllableSystemLPCControl::Stub::ConsumptionNominalMax(::grpc::ClientContext* context, const ::cs_lpc::ConsumptionNominalMaxRequest& request, ::cs_lpc::ConsumptionNominalMaxResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::cs_lpc::ConsumptionNominalMaxRequest, ::cs_lpc::ConsumptionNominalMaxResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ConsumptionNominalMax_, context, request, response);
}

void ControllableSystemLPCControl::Stub::async::ConsumptionNominalMax(::grpc::ClientContext* context, const ::cs_lpc::ConsumptionNominalMaxRequest* request, ::cs_lpc::ConsumptionNominalMaxResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::cs_lpc::ConsumptionNominalMaxRequest, ::cs_lpc::ConsumptionNominalMaxResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ConsumptionNominalMax_, context, request, response, std::move(f));
}

void ControllableSystemLPCControl::Stub::async::ConsumptionNominalMax(::grpc::ClientContext* context, const ::cs_lpc::ConsumptionNominalMaxRequest* request, ::cs_lpc::ConsumptionNominalMaxResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ConsumptionNominalMax_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::ConsumptionNominalMaxResponse>* ControllableSystemLPCControl::Stub::PrepareAsyncConsumptionNominalMaxRaw(::grpc::ClientContext* context, const ::cs_lpc::ConsumptionNominalMaxRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::cs_lpc::ConsumptionNominalMaxResponse, ::cs_lpc::ConsumptionNominalMaxRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ConsumptionNominalMax_, context, request);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::ConsumptionNominalMaxResponse>* ControllableSystemLPCControl::Stub::AsyncConsumptionNominalMaxRaw(::grpc::ClientContext* context, const ::cs_lpc::ConsumptionNominalMaxRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncConsumptionNominalMaxRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status ControllableSystemLPCControl::Stub::SetConsumptionNominalMax(::grpc::ClientContext* context, const ::cs_lpc::SetConsumptionNominalMaxRequest& request, ::cs_lpc::SetConsumptionNominalMaxResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::cs_lpc::SetConsumptionNominalMaxRequest, ::cs_lpc::SetConsumptionNominalMaxResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SetConsumptionNominalMax_, context, request, response);
}

void ControllableSystemLPCControl::Stub::async::SetConsumptionNominalMax(::grpc::ClientContext* context, const ::cs_lpc::SetConsumptionNominalMaxRequest* request, ::cs_lpc::SetConsumptionNominalMaxResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::cs_lpc::SetConsumptionNominalMaxRequest, ::cs_lpc::SetConsumptionNominalMaxResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SetConsumptionNominalMax_, context, request, response, std::move(f));
}

void ControllableSystemLPCControl::Stub::async::SetConsumptionNominalMax(::grpc::ClientContext* context, const ::cs_lpc::SetConsumptionNominalMaxRequest* request, ::cs_lpc::SetConsumptionNominalMaxResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SetConsumptionNominalMax_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::SetConsumptionNominalMaxResponse>* ControllableSystemLPCControl::Stub::PrepareAsyncSetConsumptionNominalMaxRaw(::grpc::ClientContext* context, const ::cs_lpc::SetConsumptionNominalMaxRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::cs_lpc::SetConsumptionNominalMaxResponse, ::cs_lpc::SetConsumptionNominalMaxRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SetConsumptionNominalMax_, context, request);
}

::grpc::ClientAsyncResponseReader< ::cs_lpc::SetConsumptionNominalMaxResponse>* ControllableSystemLPCControl::Stub::AsyncSetConsumptionNominalMaxRaw(::grpc::ClientContext* context, const ::cs_lpc::SetConsumptionNominalMaxRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSetConsumptionNominalMaxRaw(context, request, cq);
  result->StartCall();
  return result;
}

ControllableSystemLPCControl::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ControllableSystemLPCControl_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ControllableSystemLPCControl::Service, ::cs_lpc::ConsumptionLimitRequest, ::cs_lpc::ConsumptionLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ControllableSystemLPCControl::Service* service,
             ::grpc::ServerContext* ctx,
             const ::cs_lpc::ConsumptionLimitRequest* req,
             ::cs_lpc::ConsumptionLimitResponse* resp) {
               return service->ConsumptionLimit(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ControllableSystemLPCControl_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ControllableSystemLPCControl::Service, ::cs_lpc::SetConsumptionLimitRequest, ::cs_lpc::SetConsumptionLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ControllableSystemLPCControl::Service* service,
             ::grpc::ServerContext* ctx,
             const ::cs_lpc::SetConsumptionLimitRequest* req,
             ::cs_lpc::SetConsumptionLimitResponse* resp) {
               return service->SetConsumptionLimit(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ControllableSystemLPCControl_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ControllableSystemLPCControl::Service, ::cs_lpc::PendingConsumptionLimitRequest, ::cs_lpc::PendingConsumptionLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ControllableSystemLPCControl::Service* service,
             ::grpc::ServerContext* ctx,
             const ::cs_lpc::PendingConsumptionLimitRequest* req,
             ::cs_lpc::PendingConsumptionLimitResponse* resp) {
               return service->PendingConsumptionLimit(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ControllableSystemLPCControl_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ControllableSystemLPCControl::Service, ::cs_lpc::ApproveOrDenyConsumptionLimitRequest, ::cs_lpc::ApproveOrDenyConsumptionLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ControllableSystemLPCControl::Service* service,
             ::grpc::ServerContext* ctx,
             const ::cs_lpc::ApproveOrDenyConsumptionLimitRequest* req,
             ::cs_lpc::ApproveOrDenyConsumptionLimitResponse* resp) {
               return service->ApproveOrDenyConsumptionLimit(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ControllableSystemLPCControl_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ControllableSystemLPCControl::Service, ::cs_lpc::FailsafeConsumptionActivePowerLimitRequest, ::cs_lpc::FailsafeConsumptionActivePowerLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ControllableSystemLPCControl::Service* service,
             ::grpc::ServerContext* ctx,
             const ::cs_lpc::FailsafeConsumptionActivePowerLimitRequest* req,
             ::cs_lpc::FailsafeConsumptionActivePowerLimitResponse* resp) {
               return service->FailsafeConsumptionActivePowerLimit(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ControllableSystemLPCControl_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ControllableSystemLPCControl::Service, ::cs_lpc::SetFailsafeConsumptionActivePowerLimitRequest, ::cs_lpc::SetFailsafeConsumptionActivePowerLimitResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ControllableSystemLPCControl::Service* service,
             ::grpc::ServerContext* ctx,
             const ::cs_lpc::SetFailsafeConsumptionActivePowerLimitRequest* req,
             ::cs_lpc::SetFailsafeConsumptionActivePowerLimitResponse* resp) {
               return service->SetFailsafeConsumptionActivePowerLimit(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ControllableSystemLPCControl_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ControllableSystemLPCControl::Service, ::cs_lpc::FailsafeDurationMinimumRequest, ::cs_lpc::FailsafeDurationMinimumResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ControllableSystemLPCControl::Service* service,
             ::grpc::ServerContext* ctx,
             const ::cs_lpc::FailsafeDurationMinimumRequest* req,
             ::cs_lpc::FailsafeDurationMinimumResponse* resp) {
               return service->FailsafeDurationMinimum(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ControllableSystemLPCControl_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ControllableSystemLPCControl::Service, ::cs_lpc::SetFailsafeDurationMinimumRequest, ::cs_lpc::SetFailsafeDurationMinimumResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ControllableSystemLPCControl::Service* service,
             ::grpc::ServerContext* ctx,
             const ::cs_lpc::SetFailsafeDurationMinimumRequest* req,
             ::cs_lpc::SetFailsafeDurationMinimumResponse* resp) {
               return service->SetFailsafeDurationMinimum(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ControllableSystemLPCControl_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ControllableSystemLPCControl::Service, ::cs_lpc::StartHeartbeatRequest, ::cs_lpc::StartHeartbeatResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ControllableSystemLPCControl::Service* service,
             ::grpc::ServerContext* ctx,
             const ::cs_lpc::StartHeartbeatRequest* req,
             ::cs_lpc::StartHeartbeatResponse* resp) {
               return service->StartHeartbeat(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ControllableSystemLPCControl_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ControllableSystemLPCControl::Service, ::cs_lpc::StopHeartbeatRequest, ::cs_lpc::StopHeartbeatResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ControllableSystemLPCControl::Service* service,
             ::grpc::ServerContext* ctx,
             const ::cs_lpc::StopHeartbeatRequest* req,
             ::cs_lpc::StopHeartbeatResponse* resp) {
               return service->StopHeartbeat(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ControllableSystemLPCControl_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ControllableSystemLPCControl::Service, ::cs_lpc::IsHeartbeatWithinDurationRequest, ::cs_lpc::IsHeartbeatWithinDurationResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ControllableSystemLPCControl::Service* service,
             ::grpc::ServerContext* ctx,
             const ::cs_lpc::IsHeartbeatWithinDurationRequest* req,
             ::cs_lpc::IsHeartbeatWithinDurationResponse* resp) {
               return service->IsHeartbeatWithinDuration(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ControllableSystemLPCControl_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ControllableSystemLPCControl::Service, ::cs_lpc::ConsumptionNominalMaxRequest, ::cs_lpc::ConsumptionNominalMaxResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ControllableSystemLPCControl::Service* service,
             ::grpc::ServerContext* ctx,
             const ::cs_lpc::ConsumptionNominalMaxRequest* req,
             ::cs_lpc::ConsumptionNominalMaxResponse* resp) {
               return service->ConsumptionNominalMax(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ControllableSystemLPCControl_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< ControllableSystemLPCControl::Service, ::cs_lpc::SetConsumptionNominalMaxRequest, ::cs_lpc::SetConsumptionNominalMaxResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](ControllableSystemLPCControl::Service* service,
             ::grpc::ServerContext* ctx,
             const ::cs_lpc::SetConsumptionNominalMaxRequest* req,
             ::cs_lpc::SetConsumptionNominalMaxResponse* resp) {
               return service->SetConsumptionNominalMax(ctx, req, resp);
             }, this)));
}

ControllableSystemLPCControl::Service::~Service() {
}

::grpc::Status ControllableSystemLPCControl::Service::ConsumptionLimit(::grpc::ServerContext* context, const ::cs_lpc::ConsumptionLimitRequest* request, ::cs_lpc::ConsumptionLimitResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ControllableSystemLPCControl::Service::SetConsumptionLimit(::grpc::ServerContext* context, const ::cs_lpc::SetConsumptionLimitRequest* request, ::cs_lpc::SetConsumptionLimitResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ControllableSystemLPCControl::Service::PendingConsumptionLimit(::grpc::ServerContext* context, const ::cs_lpc::PendingConsumptionLimitRequest* request, ::cs_lpc::PendingConsumptionLimitResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ControllableSystemLPCControl::Service::ApproveOrDenyConsumptionLimit(::grpc::ServerContext* context, const ::cs_lpc::ApproveOrDenyConsumptionLimitRequest* request, ::cs_lpc::ApproveOrDenyConsumptionLimitResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ControllableSystemLPCControl::Service::FailsafeConsumptionActivePowerLimit(::grpc::ServerContext* context, const ::cs_lpc::FailsafeConsumptionActivePowerLimitRequest* request, ::cs_lpc::FailsafeConsumptionActivePowerLimitResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ControllableSystemLPCControl::Service::SetFailsafeConsumptionActivePowerLimit(::grpc::ServerContext* context, const ::cs_lpc::SetFailsafeConsumptionActivePowerLimitRequest* request, ::cs_lpc::SetFailsafeConsumptionActivePowerLimitResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ControllableSystemLPCControl::Service::FailsafeDurationMinimum(::grpc::ServerContext* context, const ::cs_lpc::FailsafeDurationMinimumRequest* request, ::cs_lpc::FailsafeDurationMinimumResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ControllableSystemLPCControl::Service::SetFailsafeDurationMinimum(::grpc::ServerContext* context, const ::cs_lpc::SetFailsafeDurationMinimumRequest* request, ::cs_lpc::SetFailsafeDurationMinimumResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ControllableSystemLPCControl::Service::StartHeartbeat(::grpc::ServerContext* context, const ::cs_lpc::StartHeartbeatRequest* request, ::cs_lpc::StartHeartbeatResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ControllableSystemLPCControl::Service::StopHeartbeat(::grpc::ServerContext* context, const ::cs_lpc::StopHeartbeatRequest* request, ::cs_lpc::StopHeartbeatResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ControllableSystemLPCControl::Service::IsHeartbeatWithinDuration(::grpc::ServerContext* context, const ::cs_lpc::IsHeartbeatWithinDurationRequest* request, ::cs_lpc::IsHeartbeatWithinDurationResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ControllableSystemLPCControl::Service::ConsumptionNominalMax(::grpc::ServerContext* context, const ::cs_lpc::ConsumptionNominalMaxRequest* request, ::cs_lpc::ConsumptionNominalMaxResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status ControllableSystemLPCControl::Service::SetConsumptionNominalMax(::grpc::ServerContext* context, const ::cs_lpc::SetConsumptionNominalMaxRequest* request, ::cs_lpc::SetConsumptionNominalMaxResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace cs_lpc

