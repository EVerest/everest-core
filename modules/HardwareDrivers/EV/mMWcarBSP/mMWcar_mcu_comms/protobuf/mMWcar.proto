syntax = "proto3";

/*
 This container message is send from EVerest to MCU and may contain any allowed message in that direction.
*/
message EverestToMcu {
 oneof payload {
  bool reset = 1;
  KeepAlive keep_alive = 2;
  BootConfigResponse config_response = 3;
  MeasRequest request_measurement = 4;
  bool get_calibration = 5;
  CalibrationValues set_calibration = 6;
  CalibrationRequest request_calibration = 7;
  CpState set_cp_state = 8;
  Adc_Raw get_adc_raw = 9;
  bool sweep_cp = 10;
  CpLUT set_cp_lut = 11;
  float set_cp_voltage = 12;
  bool set_cp_load_en = 13;
  bool set_cp_short_to_gnd_en = 14;
  bool set_cp_diode_fault_en = 15;
  }
}

/*
 This container message is send from MCU to EVerest and may contain any allowed message in that direction.
*/
message McuToEverest {
 oneof payload {
  ResetReason reset = 1;
  KeepAlive keep_alive = 2;
  BootConfigRequest config_request = 3;
  ACMeasInstant ac_meas_instant = 4;
  ACMeasStats ac_meas_statistics = 5;
  CalibrationValues calibration_values = 6;
  CalibrationResponse response_calibration = 7;
  BasicChargingCommMeasInstant basic_charging_meas_instant = 8;
  Adc_Raw adc_raw_response = 9;
  DCMeasInstant dc_meas_instant = 10;
  DacSweepResponse sweep_cp_response = 11;
  EdgeTimingMeasResult edge_timing_statistics = 12;
 }
}

enum ResetReason {
	UNKNOWN = 0;
	USER = 1;
	WDG = 2;
}

message KeepAlive {
  uint32 time_stamp = 1;
  ConfigHardwareRevisionMajor hw_revision_major = 2;
  uint32 hw_revision_minor = 3;
  string sw_version_string = 4;
}

enum ConfigHardwareRevisionMajor {
  HW_MAJOR_REV_UNKNOWN = 0;
  HW_MAJOR_REV_A = 1;
}

message MeasRequest {
  MeasRequestType type = 1;
  oneof arguments {
    EdgeTimingMeasArguments edge_timing = 2;
  }
}

enum MeasRequestType {
  MEAS_UNKNOWN = 0;
  AC_INSTANT = 1;
  AC_STATISTICS = 2;
  DC_INSTANT = 3;
  DC_STATISTICS = 4;
  BASIC_CHARGE_COMMS_INSTANT = 5;
  EDGE_TIMING = 6;
}

message ACMeasInstant {
  double Ua = 1;
  double Ub = 2;
  double Uc = 3;
}

message ACMeasStats {
	ACPhaseStats Ua = 1;
	ACPhaseStats Ub = 2;
	ACPhaseStats Uc = 3;
	uint32 sample_rate_ms = 4;
	uint32 window_len_samples = 5;
}

message ACPhaseStats {
	double min = 1;
	double max = 2;
	double avg = 3;
}

message DCMeasInstant {
	double bus_voltage = 1;
}


/* Nominal CP states */
enum CpState {
  STATE_A = 0;
  STATE_B = 1;
  STATE_C = 2;
  STATE_D = 3;
  STATE_E = 4;
  STATE_F = 5;
}

/* Nominal PP states */
enum PpState {
  STATE_NC = 0;
  STATE_13A = 1;
  STATE_20A = 2;
  STATE_32A = 3;
  STATE_70A = 4;
  STATE_FAULT = 5;
}

message BootConfigRequest {
  // TODO
}

message BootConfigResponse {
  // TODO
}

message ErrorFlags {
  // TODO
}

message CalibrationRequest {
  oneof calibration_type {
	  AC_Calibration ac = 1;
  }
}

message CalibrationResponse {
  oneof calibration_type {
	  AC_Calibration ac = 1;
  }
  uint32 value = 2;
}

message CalibrationValues {
  uint32 atm90_ua_gain = 1;
  uint32 atm90_ub_gain = 2;
  uint32 atm90_uc_gain = 3;
  uint32 atm90_ua_offset = 4;
  uint32 atm90_ub_offset = 5;
  uint32 atm90_uc_offset = 6;

  double adc_cp_gain = 7;
  double adc_cp_offset = 8;
  double adc_pp_gain = 9;
  double adc_pp_offset = 10;
  double adc_dc_gain = 11;
  double adc_dc_offset = 12;
  
  bool adc_cp_use_cal = 13;
  bool adc_pp_use_cal = 14;
  bool adc_dc_use_cal = 15;
  
  uint32 cp_load_9V_dac_val = 100;
  uint32 cp_load_6V_dac_val = 101;
  uint32 cp_load_3V_dac_val = 102;
}

enum ACPhase {
	Ua = 0;
	Ub = 1;
	Uc = 2;
}

message AC_Calibration {
	ACPhase phase = 1;
	oneof type {
		bool offset = 2;  // unused for now, MCU will detect calibration on offset by which_type
		double gain = 3;  // use this value as reference voltage passed to calibration routine
	}
}

message BasicChargingCommMeasInstant {
	bool pwm_running = 1;
	float pwm_duty = 2;
	float pwm_freq = 3;
	float cp_voltage_hi = 4;
	float cp_voltage_lo = 5;
	PpState pp = 6;
	uint32 cp_state = 7; // 0: A, 1: B, 2: C, 3: D, 4: E, 5: F, 6: DF, 7: UNKNOWN
	bool cp_load_en = 8;
	bool cp_short_to_gnd_en = 9;
	bool cp_diode_fault_en = 10;
}

enum Adc_Channel {
  CP = 0;
  PP = 1;
  DC = 2;
}

message Adc_Raw {
  Adc_Channel channel = 1;
  uint32 value = 2;
}

message DacSweepResponse {
  double cp_voltage = 1;
  uint32 dac_input = 2;
}

message CpLUT {
  repeated uint32 dac_values = 1;
}

message EdgeTimingMeasArguments {
  uint32 num_periods = 1;
  bool force_start = 2;
}

message EdgeTimingSingleEdgeResult {
  uint32 duration_max_ns = 1;
  uint32 duration_avg_ns = 2;
  uint32 duration_min_ns = 3;
}

message EdgeTimingMeasResult {
  EdgeTimingSingleEdgeResult rising = 1;
  EdgeTimingSingleEdgeResult falling = 2;
  uint32 num_periods = 3;
  CpState cp_state = 4;
}